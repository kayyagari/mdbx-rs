/* automatically generated by rust-bindgen */

pub const MDBX_VERSION_MAJOR: ::libc::c_uint = 0;
pub const MDBX_VERSION_MINOR: ::libc::c_uint = 9;
pub const MDBX_LOCKNAME: &'static [u8; 10usize] = b"/mdbx.lck\0";
pub const MDBX_DATANAME: &'static [u8; 10usize] = b"/mdbx.dat\0";
pub const MDBX_LOCK_SUFFIX: &'static [u8; 5usize] = b"-lck\0";
pub type va_list = __builtin_va_list;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __darwin_intptr_t = ::libc::c_long;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_pid_t = __int32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
    pub __arg: *mut ::libc::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::libc::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::libc::c_char; 8176usize],
}
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type pthread_t = __darwin_pthread_t;
pub type pid_t = __darwin_pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::libc::c_void,
    pub iov_len: usize,
}
pub type mdbx_pid_t = pid_t;
pub type mdbx_tid_t = pthread_t;
pub type mdbx_mode_t = mode_t;
#[doc = " \\brief libmdbx version information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_version_info {
    #[doc = "< Major version number"]
    pub major: u8,
    #[doc = "< Minor version number"]
    pub minor: u8,
    #[doc = "< Release number of Major.Minor"]
    pub release: u16,
    #[doc = "< Revision number of Release"]
    pub revision: u32,
    #[doc = "< source information from git"]
    pub git: MDBX_version_info__bindgen_ty_1,
    #[doc = "< sourcery anchor for pinning"]
    pub sourcery: *const ::libc::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_version_info__bindgen_ty_1 {
    #[doc = "< committer date, strict ISO-8601 format"]
    pub datetime: *const ::libc::c_char,
    #[doc = "< commit hash (hexadecimal digits)"]
    pub tree: *const ::libc::c_char,
    #[doc = "< tree hash, i.e. digest of the source code"]
    pub commit: *const ::libc::c_char,
    #[doc = "< git-describe string"]
    pub describe: *const ::libc::c_char,
}
extern "C" {
    pub static mdbx_version: MDBX_version_info;
}
#[doc = " \\brief libmdbx build information"]
#[doc = " \\attention Some strings could be NULL in case no corresponding information"]
#[doc = "            was provided at build time (i.e. flags)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_build_info {
    #[doc = "< build timestamp (ISO-8601 or __DATE__ __TIME__)"]
    pub datetime: *const ::libc::c_char,
    #[doc = "< cpu/arch-system-config triplet"]
    pub target: *const ::libc::c_char,
    #[doc = "< mdbx-related options"]
    pub options: *const ::libc::c_char,
    #[doc = "< compiler"]
    pub compiler: *const ::libc::c_char,
    #[doc = "< CFLAGS and CXXFLAGS"]
    pub flags: *const ::libc::c_char,
}
extern "C" {
    pub static mdbx_build: MDBX_build_info;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_env {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_txn {
    _unused: [u8; 0],
}
#[doc = " \\brief A handle for an individual database (key-value spaces) in the"]
#[doc = " environment. \\ingroup c_dbi \\details Zero handle is used internally (hidden"]
#[doc = " Garbage Collection DB). So, any valid DBI-handle great than 0 and less than"]
#[doc = " or equal \\ref MDBX_MAX_DBI. \\see mdbx_dbi_open() \\see mdbx_dbi_close()"]
pub type MDBX_dbi = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_cursor {
    _unused: [u8; 0],
}
pub type MDBX_val = iovec;
#[doc = " The hard limit for DBI handles"]
pub const MDBX_MAX_DBI: MDBX_constants = 32765;
#[doc = " The maximum size of a data item."]
pub const MDBX_MAXDATASIZE: MDBX_constants = 2147418112;
#[doc = " The minimal database page size in bytes."]
pub const MDBX_MIN_PAGESIZE: MDBX_constants = 256;
#[doc = " The maximal database page size in bytes."]
pub const MDBX_MAX_PAGESIZE: MDBX_constants = 65536;
pub type MDBX_constants = u32;
#[doc = " Critical conditions, i.e. assertion failures"]
pub const MDBX_LOG_FATAL: MDBX_log_level_t = 0;
#[doc = " Enables logging for error conditions and \\ref MDBX_LOG_FATAL"]
pub const MDBX_LOG_ERROR: MDBX_log_level_t = 1;
#[doc = " Enables logging for warning conditions and \\ref MDBX_LOG_ERROR ..."]
#[doc = "\\ref MDBX_LOG_FATAL"]
pub const MDBX_LOG_WARN: MDBX_log_level_t = 2;
#[doc = " Enables logging for normal but significant condition and"]
#[doc = "\\ref MDBX_LOG_WARN ... \\ref MDBX_LOG_FATAL"]
pub const MDBX_LOG_NOTICE: MDBX_log_level_t = 3;
#[doc = " Enables logging for verbose informational and \\ref MDBX_LOG_NOTICE ..."]
#[doc = "\\ref MDBX_LOG_FATAL"]
pub const MDBX_LOG_VERBOSE: MDBX_log_level_t = 4;
#[doc = " Enables logging for debug-level messages and \\ref MDBX_LOG_VERBOSE ..."]
#[doc = "\\ref MDBX_LOG_FATAL"]
pub const MDBX_LOG_DEBUG: MDBX_log_level_t = 5;
#[doc = " Enables logging for trace debug-level messages and \\ref MDBX_LOG_DEBUG ..."]
#[doc = "\\ref MDBX_LOG_FATAL"]
pub const MDBX_LOG_TRACE: MDBX_log_level_t = 6;
#[doc = " Enables extra debug-level messages (dump pgno lists)"]
#[doc = "and all other log-messages"]
pub const MDBX_LOG_EXTRA: MDBX_log_level_t = 7;
#[doc = " for \\ref mdbx_setup_debug() only: Don't change current settings"]
pub const MDBX_LOG_DONTCHANGE: MDBX_log_level_t = -1;
#[doc = " Log level (requires build libmdbx with \\ref MDBX_DEBUG option)"]
pub type MDBX_log_level_t = i32;
#[doc = " Enable assertion checks."]
#[doc = " Requires build with \\ref MDBX_DEBUG > 0"]
pub const MDBX_DBG_ASSERT: MDBX_debug_flags_t = 1;
#[doc = " Enable pages usage audit at commit transactions."]
#[doc = " Requires build with \\ref MDBX_DEBUG > 0"]
pub const MDBX_DBG_AUDIT: MDBX_debug_flags_t = 2;
#[doc = " Enable small random delays in critical points."]
#[doc = " Requires build with \\ref MDBX_DEBUG > 0"]
pub const MDBX_DBG_JITTER: MDBX_debug_flags_t = 4;
#[doc = " Include or not meta-pages in coredump files."]
#[doc = " May affect performance in \\ref MDBX_WRITEMAP mode"]
pub const MDBX_DBG_DUMP: MDBX_debug_flags_t = 8;
#[doc = " Allow multi-opening environment(s)"]
pub const MDBX_DBG_LEGACY_MULTIOPEN: MDBX_debug_flags_t = 16;
#[doc = " Allow read and write transactions overlapping for the same thread"]
pub const MDBX_DBG_LEGACY_OVERLAP: MDBX_debug_flags_t = 32;
#[doc = " for mdbx_setup_debug() only: Don't change current settings"]
pub const MDBX_DBG_DONTCHANGE: MDBX_debug_flags_t = -1;
#[doc = " \\brief Runtime debug flags"]
#[doc = ""]
#[doc = " \\details `MDBX_DBG_DUMP` and `MDBX_DBG_LEGACY_MULTIOPEN` always have an"]
#[doc = " effect, but `MDBX_DBG_ASSERT`, `MDBX_DBG_AUDIT` and `MDBX_DBG_JITTER` only if"]
#[doc = " libmdbx builded with \\ref MDBX_DEBUG."]
pub type MDBX_debug_flags_t = i32;
#[doc = " \\brief A debug-logger callback function,"]
#[doc = " called before printing the message and aborting."]
#[doc = " \\see mdbx_setup_debug()"]
#[doc = ""]
#[doc = " \\param [in] env  An environment handle returned by \\ref mdbx_env_create()."]
#[doc = " \\param [in] msg  The assertion message, not including newline."]
pub type MDBX_debug_func = ::std::option::Option<
    unsafe extern "C" fn(
        loglevel: MDBX_log_level_t,
        function: *const ::libc::c_char,
        line: ::libc::c_int,
        msg: *const ::libc::c_char,
        args: *mut __va_list_tag,
    ),
>;
extern "C" {
    #[doc = " \\brief Setup global log-level, debug options and debug logger."]
    #[doc = " \\returns The previously `debug_flags` in the 0-15 bits"]
    #[doc = "          and `log_level` in the 16-31 bits."]
    pub fn mdbx_setup_debug(
        log_level: MDBX_log_level_t,
        debug_flags: MDBX_debug_flags_t,
        logger: MDBX_debug_func,
    ) -> ::libc::c_int;
}
#[doc = " \\brief A callback function for most MDBX assert() failures,"]
#[doc = " called before printing the message and aborting."]
#[doc = " \\see mdbx_env_set_assert()"]
#[doc = ""]
#[doc = " \\param [in] env  An environment handle returned by mdbx_env_create()."]
#[doc = " \\param [in] msg  The assertion message, not including newline."]
pub type MDBX_assert_func = ::std::option::Option<
    unsafe extern "C" fn(
        env: *const MDBX_env,
        msg: *const ::libc::c_char,
        function: *const ::libc::c_char,
        line: ::libc::c_uint,
    ),
>;
extern "C" {
    #[doc = " \\brief Set or reset the assert() callback of the environment."]
    #[doc = ""]
    #[doc = " Does nothing if libmdbx was built with MDBX_DEBUG=0 or with NDEBUG,"]
    #[doc = " and will return `MDBX_ENOSYS` in such case."]
    #[doc = ""]
    #[doc = " \\param [in] env   An environment handle returned by mdbx_env_create()."]
    #[doc = " \\param [in] func  An MDBX_assert_func function, or 0."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_set_assert(env: *mut MDBX_env, func: MDBX_assert_func) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Dump given MDBX_val to the buffer"]
    #[doc = ""]
    #[doc = " Dumps it as string if value is printable (all bytes in the range 0x20..0x7E),"]
    #[doc = " otherwise made hexadecimal dump. Requires at least 4 byte length buffer."]
    #[doc = ""]
    #[doc = " \\returns One of:"]
    #[doc = "  - NULL if given buffer size less than 4 bytes;"]
    #[doc = "  - pointer to constant string if given value NULL or empty;"]
    #[doc = "  - otherwise pointer to given buffer."]
    pub fn mdbx_dump_val(
        key: *const MDBX_val,
        buf: *mut ::libc::c_char,
        bufsize: usize,
    ) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " \\brief Panics with message and causes abnormal process termination."]
    pub fn mdbx_panic(fmt: *const ::libc::c_char, ...);
}
pub const MDBX_ENV_DEFAULTS: MDBX_env_flags_t = 0;
#[doc = " No environment directory."]
#[doc = ""]
#[doc = " By default, MDBX creates its environment in a directory whose pathname is"]
#[doc = " given in path, and creates its data and lock files under that directory."]
#[doc = " With this option, path is used as-is for the database main data file."]
#[doc = " The database lock file is the path with \"-lck\" appended."]
#[doc = ""]
#[doc = " - with `MDBX_NOSUBDIR` = in a filesystem we have the pair of MDBX-files"]
#[doc = "   which names derived from given pathname by appending predefined suffixes."]
#[doc = ""]
#[doc = " - without `MDBX_NOSUBDIR` = in a filesystem we have the MDBX-directory with"]
#[doc = "   given pathname, within that a pair of MDBX-files with predefined names."]
#[doc = ""]
#[doc = " This flag affects only at new environment creating by \\ref mdbx_env_open(),"]
#[doc = " otherwise at opening an existing environment libmdbx will choice this"]
#[doc = " automatically."]
pub const MDBX_NOSUBDIR: MDBX_env_flags_t = 16384;
#[doc = " Read only mode."]
#[doc = ""]
#[doc = " Open the environment in read-only mode. No write operations will be"]
#[doc = " allowed. MDBX will still modify the lock file - except on read-only"]
#[doc = " filesystems, where MDBX does not use locks."]
#[doc = ""]
#[doc = " - with `MDBX_RDONLY` = open environment in read-only mode."]
#[doc = "   MDBX supports pure read-only mode (i.e. without opening LCK-file) only"]
#[doc = "   when environment directory and/or both files are not writable (and the"]
#[doc = "   LCK-file may be missing). In such case allowing file(s) to be placed"]
#[doc = "   on a network read-only share."]
#[doc = ""]
#[doc = " - without `MDBX_RDONLY` = open environment in read-write mode."]
#[doc = ""]
#[doc = " This flag affects only at environment opening but can't be changed after."]
pub const MDBX_RDONLY: MDBX_env_flags_t = 131072;
#[doc = " Open environment in exclusive/monopolistic mode."]
#[doc = ""]
#[doc = " `MDBX_EXCLUSIVE` flag can be used as a replacement for `MDB_NOLOCK`,"]
#[doc = " which don't supported by MDBX."]
#[doc = " In this way, you can get the minimal overhead, but with the correct"]
#[doc = " multi-process and multi-thread locking."]
#[doc = ""]
#[doc = " - with `MDBX_EXCLUSIVE` = open environment in exclusive/monopolistic mode"]
#[doc = "   or return \\ref MDBX_BUSY if environment already used by other process."]
#[doc = "   The main feature of the exclusive mode is the ability to open the"]
#[doc = "   environment placed on a network share."]
#[doc = ""]
#[doc = " - without `MDBX_EXCLUSIVE` = open environment in cooperative mode,"]
#[doc = "   i.e. for multi-process access/interaction/cooperation."]
#[doc = "   The main requirements of the cooperative mode are:"]
#[doc = ""]
#[doc = "   1. data files MUST be placed in the LOCAL file system,"]
#[doc = "      but NOT on a network share."]
#[doc = "   2. environment MUST be opened only by LOCAL processes,"]
#[doc = "      but NOT over a network."]
#[doc = "   3. OS kernel (i.e. file system and memory mapping implementation) and"]
#[doc = "      all processes that open the given environment MUST be running"]
#[doc = "      in the physically single RAM with cache-coherency. The only"]
#[doc = "      exception for cache-consistency requirement is Linux on MIPS"]
#[doc = "      architecture, but this case has not been tested for a long time)."]
#[doc = ""]
#[doc = " This flag affects only at environment opening but can't be changed after."]
pub const MDBX_EXCLUSIVE: MDBX_env_flags_t = 4194304;
#[doc = " Using database/environment which already opened by another process(es)."]
#[doc = ""]
#[doc = " The `MDBX_ACCEDE` flag is useful to avoid \\ref MDBX_INCOMPATIBLE error"]
#[doc = " while opening the database/environment which is already used by another"]
#[doc = " process(es) with unknown mode/flags. In such cases, if there is a"]
#[doc = " difference in the specified flags (\\ref MDBX_NOMETASYNC,"]
#[doc = " \\ref MDBX_SAFE_NOSYNC, \\ref MDBX_UTTERLY_NOSYNC, \\ref MDBX_LIFORECLAIM,"]
#[doc = " \\ref MDBX_COALESCE and \\ref MDBX_NORDAHEAD), instead of returning an error,"]
#[doc = " the database will be opened in a compatibility with the already used mode."]
#[doc = ""]
#[doc = " `MDBX_ACCEDE` has no effect if the current process is the only one either"]
#[doc = " opening the DB in read-only mode or other process(es) uses the DB in"]
#[doc = " read-only mode."]
pub const MDBX_ACCEDE: MDBX_env_flags_t = 1073741824;
#[doc = " Map data into memory with write permission."]
#[doc = ""]
#[doc = " Use a writeable memory map unless \\ref MDBX_RDONLY is set. This uses fewer"]
#[doc = " mallocs and requires much less work for tracking database pages, but"]
#[doc = " loses protection from application bugs like wild pointer writes and other"]
#[doc = " bad updates into the database. This may be slightly faster for DBs that"]
#[doc = " fit entirely in RAM, but is slower for DBs larger than RAM. Also adds the"]
#[doc = " possibility for stray application writes thru pointers to silently"]
#[doc = " corrupt the database."]
#[doc = ""]
#[doc = " - with `MDBX_WRITEMAP` = all data will be mapped into memory in the"]
#[doc = "   read-write mode. This offers a significant performance benefit, since the"]
#[doc = "   data will be modified directly in mapped memory and then flushed to disk"]
#[doc = "   by single system call, without any memory management nor copying."]
#[doc = ""]
#[doc = " - without `MDBX_WRITEMAP` = data will be mapped into memory in the"]
#[doc = "   read-only mode. This requires stocking all modified database pages in"]
#[doc = "   memory and then writing them to disk through file operations."]
#[doc = ""]
#[doc = " \\warning On the other hand, `MDBX_WRITEMAP` adds the possibility for stray"]
#[doc = " application writes thru pointers to silently corrupt the database."]
#[doc = ""]
#[doc = " \\note The `MDBX_WRITEMAP` mode is incompatible with nested transactions,"]
#[doc = " since this is unreasonable. I.e. nested transactions requires mallocation"]
#[doc = " of database pages and more work for tracking ones, which neuters a"]
#[doc = " performance boost caused by the `MDBX_WRITEMAP` mode."]
#[doc = ""]
#[doc = " This flag affects only at environment opening but can't be changed after."]
pub const MDBX_WRITEMAP: MDBX_env_flags_t = 524288;
#[doc = " Tie reader locktable slots to read-only transactions"]
#[doc = " instead of to threads."]
#[doc = ""]
#[doc = " Don't use Thread-Local Storage, instead tie reader locktable slots to"]
#[doc = " \\ref MDBX_txn objects instead of to threads. So, \\ref mdbx_txn_reset()"]
#[doc = " keeps the slot reserved for the \\ref MDBX_txn object. A thread may use"]
#[doc = " parallel read-only transactions. And a read-only transaction may span"]
#[doc = " threads if you synchronizes its use."]
#[doc = ""]
#[doc = " Applications that multiplex many user threads over individual OS threads"]
#[doc = " need this option. Such an application must also serialize the write"]
#[doc = " transactions in an OS thread, since MDBX's write locking is unaware of"]
#[doc = " the user threads."]
#[doc = ""]
#[doc = " \\note Regardless to `MDBX_NOTLS` flag a write transaction entirely should"]
#[doc = " always be used in one thread from start to finish. MDBX checks this in a"]
#[doc = " reasonable manner and return the \\ref MDBX_THREAD_MISMATCH error in rules"]
#[doc = " violation."]
#[doc = ""]
#[doc = " This flag affects only at environment opening but can't be changed after."]
pub const MDBX_NOTLS: MDBX_env_flags_t = 2097152;
#[doc = " Don't do readahead."]
#[doc = ""]
#[doc = " Turn off readahead. Most operating systems perform readahead on read"]
#[doc = " requests by default. This option turns it off if the OS supports it."]
#[doc = " Turning it off may help random read performance when the DB is larger"]
#[doc = " than RAM and system RAM is full."]
#[doc = ""]
#[doc = " By default libmdbx dynamically enables/disables readahead depending on"]
#[doc = " the actual database size and currently available memory. On the other"]
#[doc = " hand, such automation has some limitation, i.e. could be performed only"]
#[doc = " when DB size changing but can't tracks and reacts changing a free RAM"]
#[doc = " availability, since it changes independently and asynchronously."]
#[doc = ""]
#[doc = " \\note The mdbx_is_readahead_reasonable() function allows to quickly find"]
#[doc = " out whether to use readahead or not based on the size of the data and the"]
#[doc = " amount of available memory."]
#[doc = ""]
#[doc = " This flag affects only at environment opening and can't be changed after."]
pub const MDBX_NORDAHEAD: MDBX_env_flags_t = 8388608;
#[doc = " Don't initialize malloc'd memory before writing to datafile."]
#[doc = ""]
#[doc = " Don't initialize malloc'd memory before writing to unused spaces in the"]
#[doc = " data file. By default, memory for pages written to the data file is"]
#[doc = " obtained using malloc. While these pages may be reused in subsequent"]
#[doc = " transactions, freshly malloc'd pages will be initialized to zeroes before"]
#[doc = " use. This avoids persisting leftover data from other code (that used the"]
#[doc = " heap and subsequently freed the memory) into the data file."]
#[doc = ""]
#[doc = " Note that many other system libraries may allocate and free memory from"]
#[doc = " the heap for arbitrary uses. E.g., stdio may use the heap for file I/O"]
#[doc = " buffers. This initialization step has a modest performance cost so some"]
#[doc = " applications may want to disable it using this flag. This option can be a"]
#[doc = " problem for applications which handle sensitive data like passwords, and"]
#[doc = " it makes memory checkers like Valgrind noisy. This flag is not needed"]
#[doc = " with \\ref MDBX_WRITEMAP, which writes directly to the mmap instead of using"]
#[doc = " malloc for pages. The initialization is also skipped if \\ref MDBX_RESERVE"]
#[doc = " is used; the caller is expected to overwrite all of the memory that was"]
#[doc = " reserved in that case."]
#[doc = ""]
#[doc = " This flag may be changed at any time using `mdbx_env_set_flags()`."]
pub const MDBX_NOMEMINIT: MDBX_env_flags_t = 16777216;
#[doc = " Aims to coalesce a Garbage Collection items."]
#[doc = ""]
#[doc = " With `MDBX_COALESCE` flag MDBX will aims to coalesce items while recycling"]
#[doc = " a Garbage Collection. Technically, when possible short lists of pages"]
#[doc = " will be combined into longer ones, but to fit on one database page. As a"]
#[doc = " result, there will be fewer items in Garbage Collection and a page lists"]
#[doc = " are longer, which slightly increases the likelihood of returning pages to"]
#[doc = " Unallocated space and reducing the database file."]
#[doc = ""]
#[doc = " This flag may be changed at any time using mdbx_env_set_flags()."]
pub const MDBX_COALESCE: MDBX_env_flags_t = 33554432;
#[doc = " LIFO policy for recycling a Garbage Collection items."]
#[doc = ""]
#[doc = " `MDBX_LIFORECLAIM` flag turns on LIFO policy for recycling a Garbage"]
#[doc = " Collection items, instead of FIFO by default. On systems with a disk"]
#[doc = " write-back cache, this can significantly increase write performance, up"]
#[doc = " to several times in a best case scenario."]
#[doc = ""]
#[doc = " LIFO recycling policy means that for reuse pages will be taken which became"]
#[doc = " unused the lastest (i.e. just now or most recently). Therefore the loop of"]
#[doc = " database pages circulation becomes as short as possible. In other words,"]
#[doc = " the number of pages, that are overwritten in memory and on disk during a"]
#[doc = " series of write transactions, will be as small as possible. Thus creates"]
#[doc = " ideal conditions for the efficient operation of the disk write-back cache."]
#[doc = ""]
#[doc = " \\ref MDBX_LIFORECLAIM is compatible with all no-sync flags, but gives NO"]
#[doc = " noticeable impact in combination with \\ref MDBX_SAFE_NOSYNC or"]
#[doc = " \\ref MDBX_UTTERLY_NOSYNC. Because MDBX will reused pages only before the"]
#[doc = " last \"steady\" MVCC-snapshot, i.e. the loop length of database pages"]
#[doc = " circulation will be mostly defined by frequency of calling"]
#[doc = " \\ref mdbx_env_sync() rather than LIFO and FIFO difference."]
#[doc = ""]
#[doc = " This flag may be changed at any time using mdbx_env_set_flags()."]
pub const MDBX_LIFORECLAIM: MDBX_env_flags_t = 67108864;
#[doc = " Debugging option, fill/perturb released pages."]
pub const MDBX_PAGEPERTURB: MDBX_env_flags_t = 134217728;
#[doc = " Default robust and durable sync mode."]
#[doc = ""]
#[doc = " Metadata is written and flushed to disk after a data is written and"]
#[doc = " flushed, which guarantees the integrity of the database in the event"]
#[doc = " of a crash at any time."]
#[doc = ""]
#[doc = " \\attention Please do not use other modes until you have studied all the"]
#[doc = " details and are sure. Otherwise, you may lose your users' data, as happens"]
#[doc = " in [Miranda NG](https://www.miranda-ng.org/) messenger."]
pub const MDBX_SYNC_DURABLE: MDBX_env_flags_t = 0;
#[doc = " Don't sync the meta-page after commit."]
#[doc = ""]
#[doc = " Flush system buffers to disk only once per transaction commit, omit the"]
#[doc = " metadata flush. Defer that until the system flushes files to disk,"]
#[doc = " or next non-\\ref MDBX_RDONLY commit or \\ref mdbx_env_sync(). Depending on"]
#[doc = " the platform and hardware, with \\ref MDBX_NOMETASYNC you may get a doubling"]
#[doc = " of write performance."]
#[doc = ""]
#[doc = " This trade-off maintains database integrity, but a system crash may"]
#[doc = " undo the last committed transaction. I.e. it preserves the ACI"]
#[doc = " (atomicity, consistency, isolation) but not D (durability) database"]
#[doc = " property."]
#[doc = ""]
#[doc = " `MDBX_NOMETASYNC` flag may be changed at any time using"]
#[doc = " \\ref mdbx_env_set_flags() or by passing to \\ref mdbx_txn_begin() for"]
#[doc = " particular write transaction. \\see sync_modes"]
pub const MDBX_NOMETASYNC: MDBX_env_flags_t = 262144;
#[doc = " Don't sync anything but keep previous steady commits."]
#[doc = ""]
#[doc = " Like \\ref MDBX_UTTERLY_NOSYNC the `MDBX_SAFE_NOSYNC` flag disable similarly"]
#[doc = " flush system buffers to disk when committing a transaction. But there is a"]
#[doc = " huge difference in how are recycled the MVCC snapshots corresponding to"]
#[doc = " previous \"steady\" transactions (see below)."]
#[doc = ""]
#[doc = " With \\ref MDBX_WRITEMAP the `MDBX_SAFE_NOSYNC` instructs MDBX to use"]
#[doc = " asynchronous mmap-flushes to disk. Asynchronous mmap-flushes means that"]
#[doc = " actually all writes will scheduled and performed by operation system on it"]
#[doc = " own manner, i.e. unordered. MDBX itself just notify operating system that"]
#[doc = " it would be nice to write data to disk, but no more."]
#[doc = ""]
#[doc = " Depending on the platform and hardware, with `MDBX_SAFE_NOSYNC` you may get"]
#[doc = " a multiple increase of write performance, even 10 times or more."]
#[doc = ""]
#[doc = " In contrast to \\ref MDBX_UTTERLY_NOSYNC mode, with `MDBX_SAFE_NOSYNC` flag"]
#[doc = " MDBX will keeps untouched pages within B-tree of the last transaction"]
#[doc = " \"steady\" which was synced to disk completely. This has big implications for"]
#[doc = " both data durability and (unfortunately) performance:"]
#[doc = "  - a system crash can't corrupt the database, but you will lose the last"]
#[doc = "    transactions; because MDBX will rollback to last steady commit since it"]
#[doc = "    kept explicitly."]
#[doc = "  - the last steady transaction makes an effect similar to \"long-lived\" read"]
#[doc = "    transaction (see above in the \\ref restrictions section) since prevents"]
#[doc = "    reuse of pages freed by newer write transactions, thus the any data"]
#[doc = "    changes will be placed in newly allocated pages."]
#[doc = "  - to avoid rapid database growth, the system will sync data and issue"]
#[doc = "    a steady commit-point to resume reuse pages, each time there is"]
#[doc = "    insufficient space and before increasing the size of the file on disk."]
#[doc = ""]
#[doc = " In other words, with `MDBX_SAFE_NOSYNC` flag MDBX insures you from the"]
#[doc = " whole database corruption, at the cost increasing database size and/or"]
#[doc = " number of disk IOPs. So, `MDBX_SAFE_NOSYNC` flag could be used with"]
#[doc = " \\ref mdbx_env_sync() as alternatively for batch committing or nested"]
#[doc = " transaction (in some cases). As well, auto-sync feature exposed by"]
#[doc = " \\ref mdbx_env_set_syncbytes() and \\ref mdbx_env_set_syncperiod() functions"]
#[doc = " could be very useful with `MDBX_SAFE_NOSYNC` flag."]
#[doc = ""]
#[doc = " The number and volume of of disk IOPs with MDBX_SAFE_NOSYNC flag will"]
#[doc = " exactly the as without any no-sync flags. However, you should expect a"]
#[doc = " larger process's [work set](https://bit.ly/2kA2tFX) and significantly worse"]
#[doc = " a [locality of reference](https://bit.ly/2mbYq2J), due to the more"]
#[doc = " intensive allocation of previously unused pages and increase the size of"]
#[doc = " the database."]
#[doc = ""]
#[doc = " `MDBX_SAFE_NOSYNC` flag may be changed at any time using"]
#[doc = " \\ref mdbx_env_set_flags() or by passing to \\ref mdbx_txn_begin() for"]
#[doc = " particular write transaction."]
pub const MDBX_SAFE_NOSYNC: MDBX_env_flags_t = 65536;
#[doc = " \\deprecated Please use \\ref MDBX_SAFE_NOSYNC instead of `MDBX_MAPASYNC`."]
#[doc = ""]
#[doc = " Since version 0.9.x the `MDBX_MAPASYNC` is deprecated and has the same"]
#[doc = " effect as \\ref MDBX_SAFE_NOSYNC with \\ref MDBX_WRITEMAP. This just API"]
#[doc = " simplification is for convenience and clarity."]
pub const MDBX_MAPASYNC: MDBX_env_flags_t = 65536;
#[doc = " Don't sync anything and wipe previous steady commits."]
#[doc = ""]
#[doc = " Don't flush system buffers to disk when committing a transaction. This"]
#[doc = " optimization means a system crash can corrupt the database, if buffers are"]
#[doc = " not yet flushed to disk. Depending on the platform and hardware, with"]
#[doc = " `MDBX_UTTERLY_NOSYNC` you may get a multiple increase of write performance,"]
#[doc = " even 100 times or more."]
#[doc = ""]
#[doc = " If the filesystem preserves write order (which is rare and never provided"]
#[doc = " unless explicitly noted) and the \\ref MDBX_WRITEMAP and \\ref"]
#[doc = " MDBX_LIFORECLAIM flags are not used, then a system crash can't corrupt the"]
#[doc = " database, but you can lose the last transactions, if at least one buffer is"]
#[doc = " not yet flushed to disk. The risk is governed by how often the system"]
#[doc = " flushes dirty buffers to disk and how often \\ref mdbx_env_sync() is called."]
#[doc = " So, transactions exhibit ACI (atomicity, consistency, isolation) properties"]
#[doc = " and only lose `D` (durability). I.e. database integrity is maintained, but"]
#[doc = " a system crash may undo the final transactions."]
#[doc = ""]
#[doc = " Otherwise, if the filesystem not preserves write order (which is"]
#[doc = " typically) or \\ref MDBX_WRITEMAP or \\ref MDBX_LIFORECLAIM flags are used,"]
#[doc = " you should expect the corrupted database after a system crash."]
#[doc = ""]
#[doc = " So, most important thing about `MDBX_UTTERLY_NOSYNC`:"]
#[doc = "  - a system crash immediately after commit the write transaction"]
#[doc = "    high likely lead to database corruption."]
#[doc = "  - successful completion of mdbx_env_sync(force = true) after one or"]
#[doc = "    more committed transactions guarantees consistency and durability."]
#[doc = "  - BUT by committing two or more transactions you back database into"]
#[doc = "    a weak state, in which a system crash may lead to database corruption!"]
#[doc = "    In case single transaction after mdbx_env_sync, you may lose transaction"]
#[doc = "    itself, but not a whole database."]
#[doc = ""]
#[doc = " Nevertheless, `MDBX_UTTERLY_NOSYNC` provides \"weak\" durability in case"]
#[doc = " of an application crash (but no durability on system failure), and"]
#[doc = " therefore may be very useful in scenarios where data durability is"]
#[doc = " not required over a system failure (e.g for short-lived data), or if you"]
#[doc = " can take such risk."]
#[doc = ""]
#[doc = " `MDBX_UTTERLY_NOSYNC` flag may be changed at any time using"]
#[doc = " \\ref mdbx_env_set_flags(), but don't has effect if passed to"]
#[doc = " \\ref mdbx_txn_begin() for particular write transaction. \\see sync_modes"]
pub const MDBX_UTTERLY_NOSYNC: MDBX_env_flags_t = 1114112;
#[doc = " \\brief Environment flags"]
#[doc = " \\ingroup c_opening"]
#[doc = " \\anchor env_flags"]
#[doc = " \\see mdbx_env_open() \\see mdbx_env_set_flags()"]
pub type MDBX_env_flags_t = u32;
#[doc = " Start read-write transaction."]
#[doc = ""]
#[doc = " Only one write transaction may be active at a time. Writes are fully"]
#[doc = " serialized, which guarantees that writers can never deadlock."]
pub const MDBX_TXN_READWRITE: MDBX_txn_flags_t = 0;
#[doc = " Start read-only transaction."]
#[doc = ""]
#[doc = " There can be multiple read-only transactions simultaneously that do not"]
#[doc = " block each other and a write transactions."]
pub const MDBX_TXN_RDONLY: MDBX_txn_flags_t = 131072;
pub const MDBX_TXN_RDONLY_PREPARE: MDBX_txn_flags_t = 16908288;
#[doc = " Do not block when starting a write transaction."]
pub const MDBX_TXN_TRY: MDBX_txn_flags_t = 268435456;
#[doc = " Exactly the same as \\ref MDBX_NOMETASYNC,"]
#[doc = " but for this transaction only"]
pub const MDBX_TXN_NOMETASYNC: MDBX_txn_flags_t = 262144;
#[doc = " Exactly the same as \\ref MDBX_SAFE_NOSYNC,"]
#[doc = " but for this transaction only"]
pub const MDBX_TXN_NOSYNC: MDBX_txn_flags_t = 65536;
#[doc = " Transaction flags"]
#[doc = " \\ingroup c_transactions"]
#[doc = " \\anchor txn_flags"]
#[doc = " \\see mdbx_txn_begin() \\see mdbx_txn_flags()"]
pub type MDBX_txn_flags_t = u32;
pub const MDBX_DB_DEFAULTS: MDBX_db_flags_t = 0;
#[doc = " Use reverse string keys"]
pub const MDBX_REVERSEKEY: MDBX_db_flags_t = 2;
#[doc = " Use sorted duplicates, i.e. allow multi-values"]
pub const MDBX_DUPSORT: MDBX_db_flags_t = 4;
#[doc = " Numeric keys in native byte order either uint32_t or uint64_t. The keys"]
#[doc = " must all be of the same size and must be aligned while passing as"]
#[doc = " arguments."]
pub const MDBX_INTEGERKEY: MDBX_db_flags_t = 8;
#[doc = " With \\ref MDBX_DUPSORT; sorted dup items have fixed size"]
pub const MDBX_DUPFIXED: MDBX_db_flags_t = 16;
#[doc = " With \\ref MDBX_DUPSORT and with \\ref MDBX_DUPFIXED; dups are fixed size"]
#[doc = " \\ref MDBX_INTEGERKEY -style integers. The data values must all be of the"]
#[doc = " same size and must be aligned while passing as arguments."]
pub const MDBX_INTEGERDUP: MDBX_db_flags_t = 32;
#[doc = " With \\ref MDBX_DUPSORT; use reverse string comparison"]
pub const MDBX_REVERSEDUP: MDBX_db_flags_t = 64;
#[doc = " Create DB if not already existing"]
pub const MDBX_CREATE: MDBX_db_flags_t = 262144;
#[doc = " Opens an existing sub-database created with unknown flags."]
#[doc = ""]
#[doc = " The `MDBX_DB_ACCEDE` flag is intend to open a existing sub-database which"]
#[doc = " was created with unknown flags (\\ref MDBX_REVERSEKEY, \\ref MDBX_DUPSORT,"]
#[doc = " \\ref MDBX_INTEGERKEY, \\ref MDBX_DUPFIXED, \\ref MDBX_INTEGERDUP and"]
#[doc = " \\ref MDBX_REVERSEDUP)."]
#[doc = ""]
#[doc = " In such cases, instead of returning the \\ref MDBX_INCOMPATIBLE error, the"]
#[doc = " sub-database will be opened with flags which it was created, and then an"]
#[doc = " application could determine the actual flags by \\ref mdbx_dbi_flags()."]
pub const MDBX_DB_ACCEDE: MDBX_db_flags_t = 1073741824;
#[doc = " \\brief Database flags"]
#[doc = " \\ingroup c_dbi"]
#[doc = " \\anchor db_flags"]
#[doc = " \\see mdbx_dbi_open()"]
pub type MDBX_db_flags_t = u32;
#[doc = " Upsertion by default (without any other flags)"]
pub const MDBX_UPSERT: MDBX_put_flags_t = 0;
#[doc = " For insertion: Don't write if the key already exists."]
pub const MDBX_NOOVERWRITE: MDBX_put_flags_t = 16;
#[doc = " Has effect only for \\ref MDBX_DUPSORT databases."]
#[doc = " For upsertion: don't write if the key-value pair already exist."]
#[doc = " For deletion: remove all values for key."]
pub const MDBX_NODUPDATA: MDBX_put_flags_t = 32;
#[doc = " For upsertion: overwrite the current key/data pair."]
#[doc = " MDBX allows this flag for \\ref mdbx_put() for explicit overwrite/update"]
#[doc = " without insertion."]
#[doc = " For deletion: remove only single entry at the current cursor position."]
pub const MDBX_CURRENT: MDBX_put_flags_t = 64;
#[doc = " Has effect only for \\ref MDBX_DUPSORT databases."]
#[doc = " For deletion: remove all multi-values (aka duplicates) for given key."]
#[doc = " For upsertion: replace all multi-values for given key with a new one."]
pub const MDBX_ALLDUPS: MDBX_put_flags_t = 128;
#[doc = " For upsertion: Just reserve space for data, don't copy it."]
#[doc = " Return a pointer to the reserved space."]
pub const MDBX_RESERVE: MDBX_put_flags_t = 65536;
#[doc = " Data is being appended."]
#[doc = " Don't split full pages, continue on a new instead."]
pub const MDBX_APPEND: MDBX_put_flags_t = 131072;
#[doc = " Has effect only for \\ref MDBX_DUPSORT databases."]
#[doc = " Duplicate data is being appended."]
#[doc = " Don't split full pages, continue on a new instead."]
pub const MDBX_APPENDDUP: MDBX_put_flags_t = 262144;
#[doc = " Only for \\ref MDBX_DUPFIXED."]
#[doc = " Store multiple data items in one call."]
pub const MDBX_MULTIPLE: MDBX_put_flags_t = 524288;
#[doc = " \\brief Data changing flags"]
#[doc = " \\ingroup c_crud"]
#[doc = " \\see c_crud_hint"]
#[doc = " \\see mdbx_put() \\see mdbx_cursor_put() \\see mdbx_replace()"]
pub type MDBX_put_flags_t = u32;
pub const MDBX_CP_DEFAULTS: MDBX_copy_flags_t = 0;
#[doc = " Copy with compactification: Omit free space from copy and renumber all"]
#[doc = " pages sequentially"]
pub const MDBX_CP_COMPACT: MDBX_copy_flags_t = 1;
#[doc = " Force to make resizeable copy, i.e. dynamic size instead of fixed"]
pub const MDBX_CP_FORCE_DYNAMIC_SIZE: MDBX_copy_flags_t = 2;
#[doc = " \\brief Environment copy flags"]
#[doc = " \\ingroup c_extra"]
#[doc = " \\see mdbx_env_copy() \\see mdbx_env_copy2fd()"]
pub type MDBX_copy_flags_t = u32;
#[repr(u32)]
#[doc = " \\brief Cursor operations"]
#[doc = " \\ingroup c_cursors"]
#[doc = " This is the set of all operations for retrieving data using a cursor."]
#[doc = " \\see mdbx_cursor_set()"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MDBX_cursor_op {
    #[doc = " Position at first key/data item"]
    MDBX_FIRST = 0,
    #[doc = " \\ref MDBX_DUPSORT -only: Position at first data item of current key."]
    MDBX_FIRST_DUP = 1,
    #[doc = " \\ref MDBX_DUPSORT -only: Position at key/data pair."]
    MDBX_GET_BOTH = 2,
    #[doc = " \\ref MDBX_DUPSORT -only: Position at given key and at first data greater"]
    #[doc = " than or equal to specified data."]
    MDBX_GET_BOTH_RANGE = 3,
    #[doc = " Return key/data at current cursor position"]
    MDBX_GET_CURRENT = 4,
    #[doc = " \\ref MDBX_DUPFIXED -only: Return up to a page of duplicate data items"]
    #[doc = " from current cursor position. Move cursor to prepare"]
    #[doc = " for \\ref MDBX_NEXT_MULTIPLE."]
    MDBX_GET_MULTIPLE = 5,
    #[doc = " Position at last key/data item"]
    MDBX_LAST = 6,
    #[doc = " \\ref MDBX_DUPSORT -only: Position at last data item of current key."]
    MDBX_LAST_DUP = 7,
    #[doc = " Position at next data item"]
    MDBX_NEXT = 8,
    #[doc = " \\ref MDBX_DUPSORT -only: Position at next data item of current key."]
    MDBX_NEXT_DUP = 9,
    #[doc = " \\ref MDBX_DUPFIXED -only: Return up to a page of duplicate data items"]
    #[doc = " from next cursor position. Move cursor to prepare"]
    #[doc = " for `MDBX_NEXT_MULTIPLE`."]
    MDBX_NEXT_MULTIPLE = 10,
    #[doc = " Position at first data item of next key"]
    MDBX_NEXT_NODUP = 11,
    #[doc = " Position at previous data item"]
    MDBX_PREV = 12,
    #[doc = " \\ref MDBX_DUPSORT -only: Position at previous data item of current key."]
    MDBX_PREV_DUP = 13,
    #[doc = " Position at last data item of previous key"]
    MDBX_PREV_NODUP = 14,
    #[doc = " Position at specified key"]
    MDBX_SET = 15,
    #[doc = " Position at specified key, return both key and data"]
    MDBX_SET_KEY = 16,
    #[doc = " Position at first key greater than or equal to specified key."]
    MDBX_SET_RANGE = 17,
    #[doc = " \\ref MDBX_DUPFIXED -only: Position at previous page and return up to"]
    #[doc = " a page of duplicate data items."]
    MDBX_PREV_MULTIPLE = 18,
    #[doc = " Position at first key-value pair greater than or equal to specified,"]
    #[doc = " return both key and data, and the return code depends on a exact match."]
    #[doc = ""]
    #[doc = " For non DUPSORT-ed collections this work the same to \\ref MDBX_SET_RANGE,"]
    #[doc = " but returns \\ref MDBX_SUCCESS if key found exactly and"]
    #[doc = " \\ref MDBX_RESULT_TRUE if greater key was found."]
    #[doc = ""]
    #[doc = " For DUPSORT-ed a data value is taken into account for duplicates,"]
    #[doc = " i.e. for a pairs/tuples of a key and an each data value of duplicates."]
    #[doc = " Returns \\ref MDBX_SUCCESS if key-value pair found exactly and"]
    #[doc = " \\ref MDBX_RESULT_TRUE if the next pair was returned."]
    MDBX_SET_LOWERBOUND = 19,
}
#[doc = " Successful result"]
pub const MDBX_SUCCESS: MDBX_error_t = 0;
#[doc = " Alias for \\ref MDBX_SUCCESS"]
pub const MDBX_RESULT_FALSE: MDBX_error_t = 0;
#[doc = " Successful result with special meaning or a flag"]
pub const MDBX_RESULT_TRUE: MDBX_error_t = -1;
#[doc = " key/data pair already exists"]
pub const MDBX_KEYEXIST: MDBX_error_t = -30799;
#[doc = " The first LMDB-compatible defined error code"]
pub const MDBX_FIRST_LMDB_ERRCODE: MDBX_error_t = -30799;
#[doc = " key/data pair not found (EOF)"]
pub const MDBX_NOTFOUND: MDBX_error_t = -30798;
#[doc = " Requested page not found - this usually indicates corruption"]
pub const MDBX_PAGE_NOTFOUND: MDBX_error_t = -30797;
#[doc = " Database is corrupted (page was wrong type and so on)"]
pub const MDBX_CORRUPTED: MDBX_error_t = -30796;
#[doc = " Environment had fatal error,"]
#[doc = " i.e. update of meta page failed and so on."]
pub const MDBX_PANIC: MDBX_error_t = -30795;
#[doc = " DB file version mismatch with libmdbx"]
pub const MDBX_VERSION_MISMATCH: MDBX_error_t = -30794;
#[doc = " File is not a valid MDBX file"]
pub const MDBX_INVALID: MDBX_error_t = -30793;
#[doc = " Environment mapsize reached"]
pub const MDBX_MAP_FULL: MDBX_error_t = -30792;
#[doc = " Environment maxdbs reached"]
pub const MDBX_DBS_FULL: MDBX_error_t = -30791;
#[doc = " Environment maxreaders reached"]
pub const MDBX_READERS_FULL: MDBX_error_t = -30790;
#[doc = " Transaction has too many dirty pages, i.e transaction too big"]
pub const MDBX_TXN_FULL: MDBX_error_t = -30788;
#[doc = " Cursor stack too deep - this usually indicates corruption,"]
#[doc = " i.e branch-pages loop"]
pub const MDBX_CURSOR_FULL: MDBX_error_t = -30787;
#[doc = " Page has not enough space - internal error"]
pub const MDBX_PAGE_FULL: MDBX_error_t = -30786;
#[doc = " Database engine was unable to extend mapping, e.g. since address space"]
#[doc = " is unavailable or busy. This can mean:"]
#[doc = "  - Database size extended by other process beyond to environment mapsize"]
#[doc = "    and engine was unable to extend mapping while starting read"]
#[doc = "    transaction. Environment should be reopened to continue."]
#[doc = "  - Engine was unable to extend mapping during write transaction"]
#[doc = "    or explicit call of \\ref mdbx_env_set_geometry()."]
pub const MDBX_UNABLE_EXTEND_MAPSIZE: MDBX_error_t = -30785;
#[doc = " Environment or database is not compatible with the requested operation"]
#[doc = " or the specified flags. This can mean:"]
#[doc = "  - The operation expects an \\ref MDBX_DUPSORT / \\ref MDBX_DUPFIXED"]
#[doc = "    database."]
#[doc = "  - Opening a named DB when the unnamed DB has \\ref MDBX_DUPSORT /"]
#[doc = "    \\ref MDBX_INTEGERKEY."]
#[doc = "  - Accessing a data record as a database, or vice versa."]
#[doc = "  - The database was dropped and recreated with different flags."]
pub const MDBX_INCOMPATIBLE: MDBX_error_t = -30784;
#[doc = " Invalid reuse of reader locktable slot,"]
#[doc = " e.g. read-transaction already run for current thread"]
pub const MDBX_BAD_RSLOT: MDBX_error_t = -30783;
#[doc = " Transaction is not valid for requested operation,"]
#[doc = " e.g. had errored and be must aborted, has a child, or is invalid"]
pub const MDBX_BAD_TXN: MDBX_error_t = -30782;
#[doc = " Invalid size or alignment of key or data for target database,"]
#[doc = " either invalid subDB name"]
pub const MDBX_BAD_VALSIZE: MDBX_error_t = -30781;
#[doc = " The specified DBI-handle is invalid"]
#[doc = " or changed by another thread/transaction"]
pub const MDBX_BAD_DBI: MDBX_error_t = -30780;
#[doc = " Unexpected internal error, transaction should be aborted"]
pub const MDBX_PROBLEM: MDBX_error_t = -30779;
#[doc = " The last LMDB-compatible defined error code"]
pub const MDBX_LAST_LMDB_ERRCODE: MDBX_error_t = -30779;
#[doc = " Another write transaction is running or environment is already used while"]
#[doc = " opening with \\ref MDBX_EXCLUSIVE flag"]
pub const MDBX_BUSY: MDBX_error_t = -30778;
#[doc = " The first of MDBX-added error codes"]
pub const MDBX_FIRST_ADDED_ERRCODE: MDBX_error_t = -30778;
#[doc = " The specified key has more than one associated value"]
pub const MDBX_EMULTIVAL: MDBX_error_t = -30421;
#[doc = " Bad signature of a runtime object(s), this can mean:"]
#[doc = "  - memory corruption or double-free;"]
#[doc = "  - ABI version mismatch (rare case);"]
pub const MDBX_EBADSIGN: MDBX_error_t = -30420;
#[doc = " Database should be recovered, but this could NOT be done for now"]
#[doc = " since it opened in read-only mode"]
pub const MDBX_WANNA_RECOVERY: MDBX_error_t = -30419;
#[doc = " The given key value is mismatched to the current cursor position"]
pub const MDBX_EKEYMISMATCH: MDBX_error_t = -30418;
#[doc = " Database is too large for current system,"]
#[doc = " e.g. could NOT be mapped into RAM."]
pub const MDBX_TOO_LARGE: MDBX_error_t = -30417;
#[doc = " A thread has attempted to use a not owned object,"]
#[doc = " e.g. a transaction that started by another thread."]
pub const MDBX_THREAD_MISMATCH: MDBX_error_t = -30416;
#[doc = " Overlapping read and write transactions for the current thread"]
pub const MDBX_TXN_OVERLAPPING: MDBX_error_t = -30415;
#[doc = " Overlapping read and write transactions for the current thread"]
pub const MDBX_LAST_ADDED_ERRCODE: MDBX_error_t = -30415;
pub const MDBX_ENODATA: MDBX_error_t = 96;
pub const MDBX_EINVAL: MDBX_error_t = 22;
pub const MDBX_EACCESS: MDBX_error_t = 13;
pub const MDBX_ENOMEM: MDBX_error_t = 12;
pub const MDBX_EROFS: MDBX_error_t = 30;
pub const MDBX_ENOSYS: MDBX_error_t = 78;
pub const MDBX_EIO: MDBX_error_t = 5;
pub const MDBX_EPERM: MDBX_error_t = 1;
pub const MDBX_EINTR: MDBX_error_t = 4;
pub const MDBX_ENOFILE: MDBX_error_t = 2;
pub const MDBX_EREMOTE: MDBX_error_t = 15;
#[doc = " \\brief Errors and return codes"]
#[doc = " \\ingroup c_err"]
#[doc = ""]
#[doc = " BerkeleyDB uses -30800 to -30999, we'll go under them"]
#[doc = " \\see mdbx_strerror() \\see mdbx_strerror_r() \\see mdbx_liberr2str()"]
pub type MDBX_error_t = i32;
extern "C" {
    #[doc = " \\brief Return a string describing a given error code."]
    #[doc = " \\ingroup c_err"]
    #[doc = ""]
    #[doc = " This function is a superset of the ANSI C X3.159-1989 (ANSI C) `strerror()`"]
    #[doc = " function. If the error code is greater than or equal to 0, then the string"]
    #[doc = " returned by the system function `strerror()` is returned. If the error code"]
    #[doc = " is less than 0, an error string corresponding to the MDBX library error is"]
    #[doc = " returned. See errors for a list of MDBX-specific error codes."]
    #[doc = ""]
    #[doc = " `mdbx_strerror()` is NOT thread-safe because may share common internal buffer"]
    #[doc = " for system messages. The returned string must NOT be modified by the"]
    #[doc = " application, but MAY be modified by a subsequent call to"]
    #[doc = " \\ref mdbx_strerror(), `strerror()` and other related functions."]
    #[doc = " \\see mdbx_strerror_r()"]
    #[doc = ""]
    #[doc = " \\param [in] errnum  The error code."]
    #[doc = ""]
    #[doc = " \\returns \"error message\" The description of the error."]
    pub fn mdbx_strerror(errnum: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " \\brief Return a string describing a given error code."]
    #[doc = " \\ingroup c_err"]
    #[doc = ""]
    #[doc = " This function is a superset of the ANSI C X3.159-1989 (ANSI C) `strerror()`"]
    #[doc = " function. If the error code is greater than or equal to 0, then the string"]
    #[doc = " returned by the system function `strerror()` is returned. If the error code"]
    #[doc = " is less than 0, an error string corresponding to the MDBX library error is"]
    #[doc = " returned. See errors for a list of MDBX-specific error codes."]
    #[doc = ""]
    #[doc = " `mdbx_strerror_r()` is thread-safe since uses user-supplied buffer where"]
    #[doc = " appropriate. The returned string must NOT be modified by the application,"]
    #[doc = " since it may be pointer to internal constant string. However, there is no"]
    #[doc = " restriction if the returned string points to the supplied buffer."]
    #[doc = " \\see mdbx_strerror()"]
    #[doc = ""]
    #[doc = " mdbx_liberr2str() returns string describing only MDBX error numbers but NULL"]
    #[doc = " for non-MDBX error codes. This function is thread-safe since return pointer"]
    #[doc = " to constant non-localized strings."]
    #[doc = ""]
    #[doc = " \\param [in] errnum  The error code."]
    #[doc = " \\param [in,out] buf Buffer to store the error message."]
    #[doc = " \\param [in] buflen The size of buffer to store the message."]
    #[doc = ""]
    #[doc = " \\returns \"error message\" The description of the error."]
    pub fn mdbx_strerror_r(
        errnum: ::libc::c_int,
        buf: *mut ::libc::c_char,
        buflen: usize,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn mdbx_liberr2str(errnum: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " \\brief Create an MDBX environment instance."]
    #[doc = " \\ingroup c_opening"]
    #[doc = ""]
    #[doc = " This function allocates memory for a \\ref MDBX_env structure. To release"]
    #[doc = " the allocated memory and discard the handle, call \\ref mdbx_env_close()."]
    #[doc = " Before the handle may be used, it must be opened using \\ref mdbx_env_open()."]
    #[doc = ""]
    #[doc = " Various other options may also need to be set before opening the handle,"]
    #[doc = " e.g. \\ref mdbx_env_set_geometry(), \\ref mdbx_env_set_maxreaders(),"]
    #[doc = " \\ref mdbx_env_set_maxdbs(), depending on usage requirements."]
    #[doc = ""]
    #[doc = " \\param [out] penv  The address where the new handle will be stored."]
    #[doc = ""]
    #[doc = " \\returns a non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_create(penv: *mut *mut MDBX_env) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Open an environment instance."]
    #[doc = " \\ingroup c_opening"]
    #[doc = ""]
    #[doc = " Indifferently this function will fails or not, the \\ref mdbx_env_close() must"]
    #[doc = " be called later to discard the \\ref MDBX_env handle and release associated"]
    #[doc = " resources."]
    #[doc = ""]
    #[doc = " \\param [in] env       An environment handle returned"]
    #[doc = "                       by \\ref mdbx_env_create()"]
    #[doc = ""]
    #[doc = " \\param [in] pathname  The pathname for the database or the directory in which"]
    #[doc = "                       the database files reside. In the case of directory it"]
    #[doc = "                       must already exist and be writable."]
    #[doc = ""]
    #[doc = " \\param [in] flags     Special options for this environment. This parameter"]
    #[doc = "                       must be set to 0 or by bitwise OR'ing together one"]
    #[doc = "                       or more of the values described above in the"]
    #[doc = "                       \\ref env_flags and \\ref sync_modes sections."]
    #[doc = ""]
    #[doc = " Flags set by mdbx_env_set_flags() are also used:"]
    #[doc = "  - \\ref MDBX_NOSUBDIR, \\ref MDBX_RDONLY, \\ref MDBX_EXCLUSIVE,"]
    #[doc = "    \\ref MDBX_WRITEMAP, \\ref MDBX_NOTLS, \\ref MDBX_NORDAHEAD,"]
    #[doc = "    \\ref MDBX_NOMEMINIT, \\ref MDBX_COALESCE, \\ref MDBX_LIFORECLAIM."]
    #[doc = "    See \\ref env_flags section."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_NOMETASYNC, \\ref MDBX_SAFE_NOSYNC, \\ref MDBX_UTTERLY_NOSYNC."]
    #[doc = "    See \\ref sync_modes section."]
    #[doc = ""]
    #[doc = " \\note `MDB_NOLOCK` flag don't supported by MDBX,"]
    #[doc = "       try use \\ref MDBX_EXCLUSIVE as a replacement."]
    #[doc = ""]
    #[doc = " \\note MDBX don't allow to mix processes with different \\ref MDBX_SAFE_NOSYNC"]
    #[doc = "       flags on the same environment."]
    #[doc = "       In such case \\ref MDBX_INCOMPATIBLE will be returned."]
    #[doc = ""]
    #[doc = " If the database is already exist and parameters specified early by"]
    #[doc = " \\ref mdbx_env_set_geometry() are incompatible (i.e. for instance, different"]
    #[doc = " page size) then \\ref mdbx_env_open() will return \\ref MDBX_INCOMPATIBLE"]
    #[doc = " error."]
    #[doc = ""]
    #[doc = " \\param [in] mode   The UNIX permissions to set on created files."]
    #[doc = "                    Zero value means to open existing, but do not create."]
    #[doc = ""]
    #[doc = " \\return A non-zero error value on failure and 0 on success,"]
    #[doc = "         some possible errors are:"]
    #[doc = " \\retval MDBX_VERSION_MISMATCH The version of the MDBX library doesn't match"]
    #[doc = "                            the version that created the database environment."]
    #[doc = " \\retval MDBX_INVALID       The environment file headers are corrupted."]
    #[doc = " \\retval MDBX_ENOENT        The directory specified by the path parameter"]
    #[doc = "                            doesn't exist."]
    #[doc = " \\retval MDBX_EACCES        The user didn't have permission to access"]
    #[doc = "                            the environment files."]
    #[doc = " \\retval MDBX_EAGAIN        The environment was locked by another process."]
    #[doc = " \\retval MDBX_BUSY          The \\ref MDBX_EXCLUSIVE flag was specified and the"]
    #[doc = "                            environment is in use by another process,"]
    #[doc = "                            or the current process tries to open environment"]
    #[doc = "                            more than once."]
    #[doc = " \\retval MDBX_INCOMPATIBLE  Environment is already opened by another process,"]
    #[doc = "                            but with different set of \\ref MDBX_SAFE_NOSYNC,"]
    #[doc = "                            \\ref MDBX_UTTERLY_NOSYNC flags."]
    #[doc = "                            Or if the database is already exist and parameters"]
    #[doc = "                            specified early by \\ref mdbx_env_set_geometry()"]
    #[doc = "                            are incompatible (i.e. different pagesize, etc)."]
    #[doc = ""]
    #[doc = " \\retval MDBX_WANNA_RECOVERY The \\ref MDBX_RDONLY flag was specified but"]
    #[doc = "                             read-write access is required to rollback"]
    #[doc = "                             inconsistent state after a system crash."]
    #[doc = ""]
    #[doc = " \\retval MDBX_TOO_LARGE      Database is too large for this process,"]
    #[doc = "                             i.e. 32-bit process tries to open >4Gb database."]
    pub fn mdbx_env_open(
        env: *mut MDBX_env,
        pathname: *const ::libc::c_char,
        flags: MDBX_env_flags_t,
        mode: mdbx_mode_t,
    ) -> ::libc::c_int;
}
#[doc = " \\brief Just delete the environment's files and directory if any."]
#[doc = " \\note On POSIX systems, processes already working with the database will"]
#[doc = " continue to work without interference until it close the environment."]
#[doc = " \\note On Windows, the behavior of `MDB_ENV_JUST_DELETE` is different"]
#[doc = " because the system does not support deleting files that are currently"]
#[doc = " memory mapped."]
pub const MDBX_ENV_JUST_DELETE: MDBX_env_delete_mode_t = 0;
#[doc = " \\brief Make sure that the environment is not being used by other"]
#[doc = " processes, or return an error otherwise."]
pub const MDBX_ENV_ENSURE_UNUSED: MDBX_env_delete_mode_t = 1;
#[doc = " \\brief Wait until other processes closes the environment before deletion."]
pub const MDBX_ENV_WAIT_FOR_UNUSED: MDBX_env_delete_mode_t = 2;
#[doc = " \\brief Deletion modes for \\ref mdbx_env_delete()."]
#[doc = " \\ingroup c_extra"]
#[doc = " \\see mdbx_env_delete()"]
pub type MDBX_env_delete_mode_t = u32;
extern "C" {
    #[doc = " \\brief Delete the environment's files in a proper and multiprocess-safe way."]
    #[doc = " \\ingroup c_extra"]
    #[doc = ""]
    #[doc = " \\param [in] pathname  The pathname for the database or the directory in which"]
    #[doc = "                       the database files reside."]
    #[doc = ""]
    #[doc = " \\param [in] mode      Special deletion mode for the environment. This"]
    #[doc = "                       parameter must be set to one of the values described"]
    #[doc = "                       above in the \\ref MDBX_env_delete_mode_t section."]
    #[doc = ""]
    #[doc = " \\note The \\ref MDBX_ENV_JUST_DELETE don't supported on Windows since system"]
    #[doc = " unable to delete a memory-mapped files."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_RESULT_TRUE   No corresponding files or directories were found,"]
    #[doc = "                            so no deletion was performed."]
    pub fn mdbx_env_delete(
        pathname: *const ::libc::c_char,
        mode: MDBX_env_delete_mode_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Copy an MDBX environment to the specified path, with options."]
    #[doc = " \\ingroup c_extra"]
    #[doc = ""]
    #[doc = " This function may be used to make a backup of an existing environment."]
    #[doc = " No lockfile is created, since it gets recreated at need."]
    #[doc = " \\note This call can trigger significant file size growth if run in"]
    #[doc = " parallel with write transactions, because it employs a read-only"]
    #[doc = " transaction. See long-lived transactions under \\ref restrictions section."]
    #[doc = ""]
    #[doc = " \\param [in] env    An environment handle returned by mdbx_env_create()."]
    #[doc = "                    It must have already been opened successfully."]
    #[doc = " \\param [in] dest   The pathname of a file in which the copy will reside."]
    #[doc = "                    This file must not be already exist, but parent directory"]
    #[doc = "                    must be writable."]
    #[doc = " \\param [in] flags  Special options for this operation. This parameter must"]
    #[doc = "                    be set to 0 or by bitwise OR'ing together one or more"]
    #[doc = "                    of the values described here:"]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_CP_COMPACT"]
    #[doc = "      Perform compaction while copying: omit free pages and sequentially"]
    #[doc = "      renumber all pages in output. This option consumes little bit more"]
    #[doc = "      CPU for processing, but may running quickly than the default, on"]
    #[doc = "      account skipping free pages."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_CP_FORCE_DYNAMIC_SIZE"]
    #[doc = "      Force to make resizeable copy, i.e. dynamic size instead of fixed."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_copy(
        env: *mut MDBX_env,
        dest: *const ::libc::c_char,
        flags: MDBX_copy_flags_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Copy an environment to the specified file descriptor, with"]
    #[doc = " options. \\ingroup c_extra"]
    #[doc = ""]
    #[doc = " This function may be used to make a backup of an existing environment."]
    #[doc = " No lockfile is created, since it gets recreated at need."]
    #[doc = " \\see mdbx_env_copy()"]
    #[doc = ""]
    #[doc = " \\note This call can trigger significant file size growth if run in"]
    #[doc = "       parallel with write transactions, because it employs a read-only"]
    #[doc = "       transaction. See long-lived transactions under \\ref restrictions"]
    #[doc = "       section."]
    #[doc = ""]
    #[doc = " \\note Fails if the environment has suffered a page leak and the destination"]
    #[doc = "       file descriptor is associated with a pipe, socket, or FIFO."]
    #[doc = ""]
    #[doc = " \\param [in] env     An environment handle returned by mdbx_env_create()."]
    #[doc = "                     It must have already been opened successfully."]
    #[doc = " \\param [in] fd      The file descriptor to write the copy to. It must have"]
    #[doc = "                     already been opened for Write access."]
    #[doc = " \\param [in] flags   Special options for this operation. \\see mdbx_env_copy()"]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_copy2fd(
        env: *mut MDBX_env,
        fd: mdbx_filehandle_t,
        flags: MDBX_copy_flags_t,
    ) -> ::libc::c_int;
}
#[doc = " \\brief Statistics for a database in the environment"]
#[doc = " \\ingroup c_statinfo"]
#[doc = " \\see mdbx_env_stat_ex() \\see mdbx_dbi_stat()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_stat {
    #[doc = "< Size of a database page. This is the same for all"]
    #[doc = "databases."]
    pub ms_psize: u32,
    #[doc = "< Depth (height) of the B-tree"]
    pub ms_depth: u32,
    #[doc = "< Number of internal (non-leaf) pages"]
    pub ms_branch_pages: u64,
    #[doc = "< Number of leaf pages"]
    pub ms_leaf_pages: u64,
    #[doc = "< Number of overflow pages"]
    pub ms_overflow_pages: u64,
    #[doc = "< Number of data items"]
    pub ms_entries: u64,
    #[doc = "< Transaction ID of committed last modification"]
    pub ms_mod_txnid: u64,
}
extern "C" {
    #[doc = " \\brief Return statistics about the MDBX environment."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " At least one of env or txn argument must be non-null. If txn is passed"]
    #[doc = " non-null then stat will be filled accordingly to the given transaction."]
    #[doc = " Otherwise, if txn is null, then stat will be populated by a snapshot from"]
    #[doc = " the last committed write transaction, and at next time, other information"]
    #[doc = " can be returned."]
    #[doc = ""]
    #[doc = " Legacy mdbx_env_stat() correspond to calling \\ref mdbx_env_stat_ex() with the"]
    #[doc = " null `txn` argument."]
    #[doc = ""]
    #[doc = " \\param [in] env     An environment handle returned by \\ref mdbx_env_create()"]
    #[doc = " \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin()"]
    #[doc = " \\param [out] stat   The address of an \\ref MDBX_stat structure where"]
    #[doc = "                     the statistics will be copied"]
    #[doc = " \\param [in] bytes   The size of \\ref MDBX_stat."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_stat_ex(
        env: *const MDBX_env,
        txn: *const MDBX_txn,
        stat: *mut MDBX_stat,
        bytes: usize,
    ) -> ::libc::c_int;
}
#[doc = " \\brief Information about the environment"]
#[doc = " \\ingroup c_statinfo"]
#[doc = " \\see mdbx_env_info_ex()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_envinfo {
    pub mi_geo: MDBX_envinfo__bindgen_ty_1,
    #[doc = "< Size of the data memory map"]
    pub mi_mapsize: u64,
    #[doc = "< Number of the last used page"]
    pub mi_last_pgno: u64,
    #[doc = "< ID of the last committed transaction"]
    pub mi_recent_txnid: u64,
    #[doc = "< ID of the last reader transaction"]
    pub mi_latter_reader_txnid: u64,
    #[doc = "< ID of the last reader transaction"]
    #[doc = "of caller process"]
    pub mi_self_latter_reader_txnid: u64,
    pub mi_meta0_txnid: u64,
    pub mi_meta0_sign: u64,
    pub mi_meta1_txnid: u64,
    pub mi_meta1_sign: u64,
    pub mi_meta2_txnid: u64,
    pub mi_meta2_sign: u64,
    #[doc = "< Total reader slots in the environment"]
    pub mi_maxreaders: u32,
    #[doc = "< Max reader slots used in the environment"]
    pub mi_numreaders: u32,
    #[doc = "< Database pagesize"]
    pub mi_dxb_pagesize: u32,
    #[doc = "< System pagesize"]
    pub mi_sys_pagesize: u32,
    pub mi_bootid: MDBX_envinfo__bindgen_ty_2,
    #[doc = " Bytes not explicitly synchronized to disk"]
    pub mi_unsync_volume: u64,
    #[doc = " Current auto-sync threshold, see \\ref mdbx_env_set_syncbytes()."]
    pub mi_autosync_threshold: u64,
    #[doc = " Time since the last steady sync in 1/65536 of second"]
    pub mi_since_sync_seconds16dot16: u32,
    #[doc = " Current auto-sync period in 1/65536 of second,"]
    #[doc = " see \\ref mdbx_env_set_syncperiod()."]
    pub mi_autosync_period_seconds16dot16: u32,
    #[doc = " Time since the last readers check in 1/65536 of second,"]
    #[doc = " see \\ref mdbx_reader_check()."]
    pub mi_since_reader_check_seconds16dot16: u32,
    #[doc = " Current environment mode."]
    #[doc = " The same as \\ref mdbx_env_get_flags() returns."]
    pub mi_mode: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_envinfo__bindgen_ty_1 {
    #[doc = "< Lower limit for datafile size"]
    pub lower: u64,
    #[doc = "< Upper limit for datafile size"]
    pub upper: u64,
    #[doc = "< Current datafile size"]
    pub current: u64,
    #[doc = "< Shrink threshold for datafile"]
    pub shrink: u64,
    #[doc = "< Growth step for datafile"]
    pub grow: u64,
}
#[doc = " \\brief A mostly unique ID that is regenerated on each boot."]
#[doc = ""]
#[doc = "As such it can be used to identify the local machine's current boot. MDBX"]
#[doc = "uses such when open the database to determine whether rollback required to"]
#[doc = "the last steady sync point or not. I.e. if current bootid is differ from the"]
#[doc = "value within a database then the system was rebooted and all changes since"]
#[doc = "last steady sync must be reverted for data integrity. Zeros mean that no"]
#[doc = "relevant information is available from the system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_envinfo__bindgen_ty_2 {
    pub current: MDBX_envinfo__bindgen_ty_2__bindgen_ty_1,
    pub meta0: MDBX_envinfo__bindgen_ty_2__bindgen_ty_1,
    pub meta1: MDBX_envinfo__bindgen_ty_2__bindgen_ty_1,
    pub meta2: MDBX_envinfo__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_envinfo__bindgen_ty_2__bindgen_ty_1 {
    pub x: u64,
    pub y: u64,
}
extern "C" {
    #[doc = " \\brief Return information about the MDBX environment."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " At least one of env or txn argument must be non-null. If txn is passed"]
    #[doc = " non-null then stat will be filled accordingly to the given transaction."]
    #[doc = " Otherwise, if txn is null, then stat will be populated by a snapshot from"]
    #[doc = " the last committed write transaction, and at next time, other information"]
    #[doc = " can be returned."]
    #[doc = ""]
    #[doc = " Legacy \\ref mdbx_env_info() correspond to calling \\ref mdbx_env_info_ex()"]
    #[doc = " with the null `txn` argument."]
    #[doc = ""]
    #[doc = " \\param [in] env     An environment handle returned by \\ref mdbx_env_create()"]
    #[doc = " \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin()"]
    #[doc = " \\param [out] info   The address of an \\ref MDBX_envinfo structure"]
    #[doc = "                     where the information will be copied"]
    #[doc = " \\param [in] bytes   The size of \\ref MDBX_envinfo."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_info_ex(
        env: *const MDBX_env,
        txn: *const MDBX_txn,
        info: *mut MDBX_envinfo,
        bytes: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Flush the environment data buffers to disk."]
    #[doc = " \\ingroup c_extra"]
    #[doc = ""]
    #[doc = " Unless the environment was opened with no-sync flags (\\ref MDBX_NOMETASYNC,"]
    #[doc = " \\ref MDBX_SAFE_NOSYNC and \\ref MDBX_UTTERLY_NOSYNC), then"]
    #[doc = " data is always written an flushed to disk when \\ref mdbx_txn_commit() is"]
    #[doc = " called. Otherwise \\ref mdbx_env_sync() may be called to manually write and"]
    #[doc = " flush unsynced data to disk."]
    #[doc = ""]
    #[doc = " Besides, \\ref mdbx_env_sync_ex() with argument `force=false` may be used to"]
    #[doc = " provide polling mode for lazy/asynchronous sync in conjunction with"]
    #[doc = " \\ref mdbx_env_set_syncbytes() and/or \\ref mdbx_env_set_syncperiod()."]
    #[doc = ""]
    #[doc = " \\note This call is not valid if the environment was opened with MDBX_RDONLY."]
    #[doc = ""]
    #[doc = " \\param [in] env      An environment handle returned by \\ref mdbx_env_create()"]
    #[doc = " \\param [in] force    If non-zero, force a flush. Otherwise, If force is"]
    #[doc = "                      zero, then will run in polling mode,"]
    #[doc = "                      i.e. it will check the thresholds that were"]
    #[doc = "                      set \\ref mdbx_env_set_syncbytes()"]
    #[doc = "                      and/or \\ref mdbx_env_set_syncperiod() and perform flush"]
    #[doc = "                      if at least one of the thresholds is reached."]
    #[doc = ""]
    #[doc = " \\param [in] nonblock Don't wait if write transaction"]
    #[doc = "                      is running by other thread."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and \\ref MDBX_RESULT_TRUE or 0 on"]
    #[doc = "     success. The \\ref MDBX_RESULT_TRUE means no data pending for flush"]
    #[doc = "     to disk, and 0 otherwise. Some possible errors are:"]
    #[doc = ""]
    #[doc = " \\retval MDBX_EACCES   the environment is read-only."]
    #[doc = " \\retval MDBX_BUSY     the environment is used by other thread"]
    #[doc = "                       and `nonblock=true`."]
    #[doc = " \\retval MDBX_EINVAL   an invalid parameter was specified."]
    #[doc = " \\retval MDBX_EIO      an error occurred during synchronization."]
    pub fn mdbx_env_sync_ex(env: *mut MDBX_env, force: bool, nonblock: bool) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Sets threshold to force flush the data buffers to disk, even any of"]
    #[doc = " \\ref MDBX_SAFE_NOSYNC flag in the environment."]
    #[doc = " \\ingroup c_settings"]
    #[doc = ""]
    #[doc = " The threshold value affects all processes which operates with given"]
    #[doc = " environment until the last process close environment or a new value will be"]
    #[doc = " settled."]
    #[doc = ""]
    #[doc = " Data is always written to disk when \\ref mdbx_txn_commit() is called, but"]
    #[doc = " the operating system may keep it buffered. MDBX always flushes the OS buffers"]
    #[doc = " upon commit as well, unless the environment was opened with"]
    #[doc = " \\ref MDBX_SAFE_NOSYNC, \\ref MDBX_UTTERLY_NOSYNC"]
    #[doc = " or in part \\ref MDBX_NOMETASYNC."]
    #[doc = ""]
    #[doc = " The default is 0, than mean no any threshold checked, and no additional"]
    #[doc = " flush will be made."]
    #[doc = ""]
    #[doc = " \\param [in] env         An environment handle returned by mdbx_env_create()."]
    #[doc = " \\param [in] threshold   The size in bytes of summary changes when"]
    #[doc = "                         a synchronous flush would be made."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_set_syncbytes(env: *mut MDBX_env, threshold: usize) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Sets relative period since the last unsteady commit to force flush"]
    #[doc = " the data buffers to disk, even of \\ref MDBX_SAFE_NOSYNC flag in the"]
    #[doc = " environment."]
    #[doc = ""]
    #[doc = " \\ingroup c_settings"]
    #[doc = ""]
    #[doc = " The relative period value affects all processes which operates with given"]
    #[doc = " environment until the last process close environment or a new value will be"]
    #[doc = " settled."]
    #[doc = ""]
    #[doc = " Data is always written to disk when \\ref mdbx_txn_commit() is called, but the"]
    #[doc = " operating system may keep it buffered. MDBX always flushes the OS buffers"]
    #[doc = " upon commit as well, unless the environment was opened with"]
    #[doc = " \\ref MDBX_SAFE_NOSYNC or in part \\ref MDBX_NOMETASYNC."]
    #[doc = ""]
    #[doc = " Settled period don't checked asynchronously, but only by the"]
    #[doc = " \\ref mdbx_txn_commit() and \\ref mdbx_env_sync() functions. Therefore, in"]
    #[doc = " cases where transactions are committed infrequently and/or irregularly,"]
    #[doc = " polling by \\ref mdbx_env_sync() may be a reasonable solution to timeout"]
    #[doc = " enforcement."]
    #[doc = ""]
    #[doc = " The default is 0, than mean no any timeout checked, and no additional"]
    #[doc = " flush will be made."]
    #[doc = ""]
    #[doc = " \\param [in] env   An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = " \\param [in] seconds_16dot16  The period in 1/65536 of second when"]
    #[doc = "                              a synchronous flush would be made since"]
    #[doc = "                              the last unsteady commit."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_set_syncperiod(
        env: *mut MDBX_env,
        seconds_16dot16: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Close the environment and release the memory map."]
    #[doc = " \\ingroup c_opening"]
    #[doc = ""]
    #[doc = " Only a single thread may call this function. All transactions, databases,"]
    #[doc = " and cursors must already be closed before calling this function. Attempts"]
    #[doc = " to use any such handles after calling this function will cause a `SIGSEGV`."]
    #[doc = " The environment handle will be freed and must not be used again after this"]
    #[doc = " call."]
    #[doc = ""]
    #[doc = " \\param [in] env        An environment handle returned by"]
    #[doc = "                        \\ref mdbx_env_create()."]
    #[doc = ""]
    #[doc = " \\param [in] dont_sync  A dont'sync flag, if non-zero the last checkpoint"]
    #[doc = "                        will be kept \"as is\" and may be still \"weak\" in the"]
    #[doc = "                        \\ref MDBX_SAFE_NOSYNC or \\ref MDBX_UTTERLY_NOSYNC"]
    #[doc = "                        modes. Such \"weak\" checkpoint will be ignored on"]
    #[doc = "                        opening next time, and transactions since the last"]
    #[doc = "                        non-weak checkpoint (meta-page update) will rolledback"]
    #[doc = "                        for consistency guarantee."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_BUSY   The write transaction is running by other thread,"]
    #[doc = "                     in such case \\ref MDBX_env instance has NOT be destroyed"]
    #[doc = "                     not released!"]
    #[doc = "                     \\note If any OTHER error code was returned then"]
    #[doc = "                     given MDBX_env instance has been destroyed and released."]
    #[doc = ""]
    #[doc = " \\retval MDBX_EBADSIGN  Environment handle already closed or not valid,"]
    #[doc = "                        i.e. \\ref mdbx_env_close() was already called for the"]
    #[doc = "                        `env` or was not created by \\ref mdbx_env_create()."]
    #[doc = ""]
    #[doc = " \\retval MDBX_PANIC  If \\ref mdbx_env_close_ex() was called in the child"]
    #[doc = "                     process after `fork()`. In this case \\ref MDBX_PANIC"]
    #[doc = "                     is expected, i.e. \\ref MDBX_env instance was freed in"]
    #[doc = "                     proper manner."]
    #[doc = ""]
    #[doc = " \\retval MDBX_EIO    An error occurred during synchronization."]
    pub fn mdbx_env_close_ex(env: *mut MDBX_env, dont_sync: bool) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Set environment flags."]
    #[doc = " \\ingroup c_settings"]
    #[doc = ""]
    #[doc = " This may be used to set some flags in addition to those from"]
    #[doc = " mdbx_env_open(), or to unset these flags."]
    #[doc = " \\see mdbx_env_get_flags()"]
    #[doc = ""]
    #[doc = " \\note In contrast to LMDB, the MDBX serialize threads via mutex while"]
    #[doc = " changing the flags. Therefore this function will be blocked while a write"]
    #[doc = " transaction running by other thread, or \\ref MDBX_BUSY will be returned if"]
    #[doc = " function called within a write transaction."]
    #[doc = ""]
    #[doc = " \\param [in] env      An environment handle returned"]
    #[doc = "                      by \\ref mdbx_env_create()."]
    #[doc = " \\param [in] flags    The \\ref env_flags to change, bitwise OR'ed together."]
    #[doc = " \\param [in] onoff    A non-zero value sets the flags, zero clears them."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_env_set_flags(
        env: *mut MDBX_env,
        flags: MDBX_env_flags_t,
        onoff: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get environment flags."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = " \\see mdbx_env_set_flags()"]
    #[doc = ""]
    #[doc = " \\param [in] env     An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = " \\param [out] flags  The address of an integer to store the flags."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_EINVAL An invalid parameter was specified."]
    pub fn mdbx_env_get_flags(env: *const MDBX_env, flags: *mut ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Return the path that was used in mdbx_env_open()."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " \\param [in] env     An environment handle returned by \\ref mdbx_env_create()"]
    #[doc = " \\param [out] dest   Address of a string pointer to contain the path."]
    #[doc = "                     This is the actual string in the environment, not a"]
    #[doc = "                     copy. It should not be altered in any way."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_env_get_path(
        env: *const MDBX_env,
        dest: *mut *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Return the file descriptor for the given environment."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " \\note All MDBX file descriptors have `FD_CLOEXEC` and"]
    #[doc = "       couldn't be used after exec() and or `fork()`."]
    #[doc = ""]
    #[doc = " \\param [in] env   An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = " \\param [out] fd   Address of a int to contain the descriptor."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_env_get_fd(env: *const MDBX_env, fd: *mut mdbx_filehandle_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Set all size-related parameters of environment, including page size"]
    #[doc = " and the min/max size of the memory map. \\ingroup c_settings"]
    #[doc = ""]
    #[doc = " In contrast to LMDB, the MDBX provide automatic size management of an"]
    #[doc = " database according the given parameters, including shrinking and resizing"]
    #[doc = " on the fly. From user point of view all of these just working. Nevertheless,"]
    #[doc = " it is reasonable to know some details in order to make optimal decisions"]
    #[doc = " when choosing parameters."]
    #[doc = ""]
    #[doc = " Both \\ref mdbx_env_info_ex() and legacy \\ref mdbx_env_info() are inapplicable"]
    #[doc = " to read-only opened environment."]
    #[doc = ""]
    #[doc = " Both \\ref mdbx_env_info_ex() and legacy \\ref mdbx_env_info() could be called"]
    #[doc = " either before or after \\ref mdbx_env_open(), either within the write"]
    #[doc = " transaction running by current thread or not:"]
    #[doc = ""]
    #[doc = "  - In case \\ref mdbx_env_info_ex() or legacy \\ref mdbx_env_info() was called"]
    #[doc = "    BEFORE \\ref mdbx_env_open(), i.e. for closed environment, then the"]
    #[doc = "    specified parameters will be used for new database creation, or will be"]
    #[doc = "    applied during opening if database exists and no other process using it."]
    #[doc = ""]
    #[doc = "    If the database is already exist, opened with \\ref MDBX_EXCLUSIVE or not"]
    #[doc = "    used by any other process, and parameters specified by"]
    #[doc = "    \\ref mdbx_env_set_geometry() are incompatible (i.e. for instance,"]
    #[doc = "    different page size) then \\ref mdbx_env_open() will return"]
    #[doc = "    \\ref MDBX_INCOMPATIBLE error."]
    #[doc = ""]
    #[doc = "    In another way, if database will opened read-only or will used by other"]
    #[doc = "    process during calling \\ref mdbx_env_open() that specified parameters will"]
    #[doc = "    silently discarded (open the database with \\ref MDBX_EXCLUSIVE flag"]
    #[doc = "    to avoid this)."]
    #[doc = ""]
    #[doc = "  - In case \\ref mdbx_env_info_ex() or legacy \\ref mdbx_env_info() was called"]
    #[doc = "    after \\ref mdbx_env_open() WITHIN the write transaction running by current"]
    #[doc = "    thread, then specified parameters will be applied as a part of write"]
    #[doc = "    transaction, i.e. will not be visible to any others processes until the"]
    #[doc = "    current write transaction has been committed by the current process."]
    #[doc = "    However, if transaction will be aborted, then the database file will be"]
    #[doc = "    reverted to the previous size not immediately, but when a next transaction"]
    #[doc = "    will be committed or when the database will be opened next time."]
    #[doc = ""]
    #[doc = "  - In case \\ref mdbx_env_info_ex() or legacy \\ref mdbx_env_info() was called"]
    #[doc = "    after \\ref mdbx_env_open() but OUTSIDE a write transaction, then MDBX will"]
    #[doc = "    execute internal pseudo-transaction to apply new parameters (but only if"]
    #[doc = "    anything has been changed), and changes be visible to any others processes"]
    #[doc = "    immediately after succesful completion of function."]
    #[doc = ""]
    #[doc = " Essentially a concept of \"automatic size management\" is simple and useful:"]
    #[doc = "  - There are the lower and upper bound of the database file size;"]
    #[doc = "  - There is the growth step by which the database file will be increased,"]
    #[doc = "    in case of lack of space."]
    #[doc = "  - There is the threshold for unused space, beyond which the database file"]
    #[doc = "    will be shrunk."]
    #[doc = "  - The size of the memory map is also the maximum size of the database."]
    #[doc = "  - MDBX will automatically manage both the size of the database and the size"]
    #[doc = "    of memory map, according to the given parameters."]
    #[doc = ""]
    #[doc = " So, there some considerations about choosing these parameters:"]
    #[doc = "  - The lower bound allows you to prevent database shrinking below some"]
    #[doc = "    rational size to avoid unnecessary resizing costs."]
    #[doc = "  - The upper bound allows you to prevent database growth above some rational"]
    #[doc = "    size. Besides, the upper bound defines the linear address space"]
    #[doc = "    reservation in each process that opens the database. Therefore changing"]
    #[doc = "    the upper bound is costly and may be required reopening environment in"]
    #[doc = "    case of \\ref MDBX_UNABLE_EXTEND_MAPSIZE errors, and so on. Therefore, this"]
    #[doc = "    value should be chosen reasonable as large as possible, to accommodate"]
    #[doc = "    future growth of the database."]
    #[doc = "  - The growth step must be greater than zero to allow the database to grow,"]
    #[doc = "    but also reasonable not too small, since increasing the size by little"]
    #[doc = "    steps will result a large overhead."]
    #[doc = "  - The shrink threshold must be greater than zero to allow the database"]
    #[doc = "    to shrink but also reasonable not too small (to avoid extra overhead) and"]
    #[doc = "    not less than growth step to avoid up-and-down flouncing."]
    #[doc = "  - The current size (i.e. size_now argument) is an auxiliary parameter for"]
    #[doc = "    simulation legacy \\ref mdbx_env_set_mapsize() and as workaround Windows"]
    #[doc = "    issues (see below)."]
    #[doc = ""]
    #[doc = " Unfortunately, Windows has is a several issues"]
    #[doc = " with resizing of memory-mapped file:"]
    #[doc = "  - Windows unable shrinking a memory-mapped file (i.e memory-mapped section)"]
    #[doc = "    in any way except unmapping file entirely and then map again. Moreover,"]
    #[doc = "    it is impossible in any way if a memory-mapped file is used more than"]
    #[doc = "    one process."]
    #[doc = "  - Windows does not provide the usual API to augment a memory-mapped file"]
    #[doc = "    (that is, a memory-mapped partition), but only by using \"Native API\""]
    #[doc = "    in an undocumented way."]
    #[doc = ""]
    #[doc = " MDBX bypasses all Windows issues, but at a cost:"]
    #[doc = "  - Ability to resize database on the fly requires an additional lock"]
    #[doc = "    and release `SlimReadWriteLock during` each read-only transaction."]
    #[doc = "  - During resize all in-process threads should be paused and then resumed."]
    #[doc = "  - Shrinking of database file is performed only when it used by single"]
    #[doc = "    process, i.e. when a database closes by the last process or opened"]
    #[doc = "    by the first."]
    #[doc = "  = Therefore, the size_now argument may be useful to set database size"]
    #[doc = "    by the first process which open a database, and thus avoid expensive"]
    #[doc = "    remapping further."]
    #[doc = ""]
    #[doc = " For create a new database with particular parameters, including the page"]
    #[doc = " size, \\ref mdbx_env_set_geometry() should be called after"]
    #[doc = " \\ref mdbx_env_create() and before mdbx_env_open(). Once the database is"]
    #[doc = " created, the page size cannot be changed. If you do not specify all or some"]
    #[doc = " of the parameters, the corresponding default values will be used. For"]
    #[doc = " instance, the default for database size is 10485760 bytes."]
    #[doc = ""]
    #[doc = " If the mapsize is increased by another process, MDBX silently and"]
    #[doc = " transparently adopt these changes at next transaction start. However,"]
    #[doc = " \\ref mdbx_txn_begin() will return \\ref MDBX_UNABLE_EXTEND_MAPSIZE if new"]
    #[doc = " mapping size could not be applied for current process (for instance if"]
    #[doc = " address space is busy).  Therefore, in the case of"]
    #[doc = " \\ref MDBX_UNABLE_EXTEND_MAPSIZE error you need close and reopen the"]
    #[doc = " environment to resolve error."]
    #[doc = ""]
    #[doc = " \\note Actual values may be different than your have specified because of"]
    #[doc = " rounding to specified database page size, the system page size and/or the"]
    #[doc = " size of the system virtual memory management unit. You can get actual values"]
    #[doc = " by \\ref mdbx_env_sync_ex() or see by using the tool `mdbx_chk` with the `-v`"]
    #[doc = " option."]
    #[doc = ""]
    #[doc = " Legacy \\ref mdbx_env_set_mapsize() correspond to calling"]
    #[doc = " \\ref mdbx_env_set_geometry() with the arguments `size_lower`, `size_now`,"]
    #[doc = " `size_upper` equal to the `size` and `-1` (i.e. default) for all other"]
    #[doc = " parameters."]
    #[doc = ""]
    #[doc = " \\param [in] env         An environment handle returned"]
    #[doc = "                         by \\ref mdbx_env_create()"]
    #[doc = ""]
    #[doc = " \\param [in] size_lower  The lower bound of database size in bytes."]
    #[doc = "                         Zero value means \"minimal acceptable\","]
    #[doc = "                         and negative means \"keep current or use default\"."]
    #[doc = ""]
    #[doc = " \\param [in] size_now    The size in bytes to setup the database size for"]
    #[doc = "                         now. Zero value means \"minimal acceptable\", and"]
    #[doc = "                         negative means \"keep current or use default\". So,"]
    #[doc = "                         it is recommended always pass -1 in this argument"]
    #[doc = "                         except some special cases."]
    #[doc = ""]
    #[doc = " \\param [in] size_upper The upper bound of database size in bytes."]
    #[doc = "                        Zero value means \"minimal acceptable\","]
    #[doc = "                        and negative means \"keep current or use default\"."]
    #[doc = "                        It is recommended to avoid change upper bound while"]
    #[doc = "                        database is used by other processes or threaded"]
    #[doc = "                        (i.e. just pass -1 in this argument except absolutely"]
    #[doc = "                        necessary). Otherwise you must be ready for"]
    #[doc = "                        \\ref MDBX_UNABLE_EXTEND_MAPSIZE error(s), unexpected"]
    #[doc = "                        pauses during remapping and/or system errors like"]
    #[doc = "                        \"address busy\", and so on. In other words, there"]
    #[doc = "                        is no way to handle a growth of the upper bound"]
    #[doc = "                        robustly because there may be a lack of appropriate"]
    #[doc = "                        system resources (which are extremely volatile in"]
    #[doc = "                        a multi-process multi-threaded environment)."]
    #[doc = ""]
    #[doc = " \\param [in] growth_step  The growth step in bytes, must be greater than"]
    #[doc = "                          zero to allow the database to grow. Negative value"]
    #[doc = "                          means \"keep current or use default\"."]
    #[doc = ""]
    #[doc = " \\param [in] shrink_threshold  The shrink threshold in bytes, must be greater"]
    #[doc = "                               than zero to allow the database to shrink and"]
    #[doc = "                               greater than growth_step to avoid shrinking"]
    #[doc = "                               right after grow."]
    #[doc = "                               Negative value means \"keep current"]
    #[doc = "                               or use default\". Default is 2*growth_step."]
    #[doc = ""]
    #[doc = " \\param [in] pagesize          The database page size for new database"]
    #[doc = "                               creation or -1 otherwise. Must be power of 2"]
    #[doc = "                               in the range between \\ref MDBX_MIN_PAGESIZE and"]
    #[doc = "                               \\ref MDBX_MAX_PAGESIZE. Zero value means"]
    #[doc = "                               \"minimal acceptable\", and negative means"]
    #[doc = "                               \"keep current or use default\"."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_EINVAL    An invalid parameter was specified,"]
    #[doc = "                        or the environment has an active write transaction."]
    #[doc = " \\retval MDBX_EPERM     Specific for Windows: Shrinking was disabled before"]
    #[doc = "                        and now it wanna be enabled, but there are reading"]
    #[doc = "                        threads that don't use the additional `SRWL` (that"]
    #[doc = "                        is required to avoid Windows issues)."]
    #[doc = " \\retval MDBX_EACCESS   The environment opened in read-only."]
    #[doc = " \\retval MDBX_MAP_FULL  Specified size smaller than the space already"]
    #[doc = "                        consumed by the environment."]
    #[doc = " \\retval MDBX_TOO_LARGE Specified size is too large, i.e. too many pages for"]
    #[doc = "                        given size, or a 32-bit process requests too much"]
    #[doc = "                        bytes for the 32-bit address space."]
    pub fn mdbx_env_set_geometry(
        env: *mut MDBX_env,
        size_lower: isize,
        size_now: isize,
        size_upper: isize,
        growth_step: isize,
        shrink_threshold: isize,
        pagesize: isize,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Find out whether to use readahead or not, based on the given database"]
    #[doc = " size and the amount of available memory. \\ingroup c_extra"]
    #[doc = ""]
    #[doc = " \\param [in] volume      The expected database size in bytes."]
    #[doc = " \\param [in] redundancy  Additional reserve or overload in case of negative"]
    #[doc = "                         value."]
    #[doc = ""]
    #[doc = " \\returns A \\ref MDBX_RESULT_TRUE or \\ref MDBX_RESULT_FALSE value,"]
    #[doc = "          otherwise the error code:"]
    #[doc = " \\retval MDBX_RESULT_TRUE   Readahead is reasonable."]
    #[doc = " \\retval MDBX_RESULT_FALSE  Readahead is NOT reasonable,"]
    #[doc = "                            i.e. \\ref MDBX_NORDAHEAD is useful to"]
    #[doc = "                            open environment by \\ref mdbx_env_open()."]
    #[doc = " \\retval Otherwise the error code."]
    pub fn mdbx_is_readahead_reasonable(volume: usize, redundancy: isize) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Returns minimal database size in bytes for given page size,"]
    #[doc = " or -1 if pagesize is invalid."]
    #[doc = " \\ingroup c_statinfo"]
    pub fn mdbx_limits_dbsize_min(pagesize: isize) -> isize;
}
extern "C" {
    #[doc = " \\brief Returns maximal database size in bytes for given page size,"]
    #[doc = " or -1 if pagesize is invalid."]
    #[doc = " \\ingroup c_statinfo"]
    pub fn mdbx_limits_dbsize_max(pagesize: isize) -> isize;
}
extern "C" {
    #[doc = " \\brief Returns maximal key size in bytes for given page size"]
    #[doc = " and database flags, or -1 if pagesize is invalid."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = " \\see db_flags"]
    pub fn mdbx_limits_keysize_max(pagesize: isize, flags: MDBX_db_flags_t) -> isize;
}
extern "C" {
    #[doc = " \\brief Returns maximal data size in bytes for given page size"]
    #[doc = " and database flags, or -1 if pagesize is invalid."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = " \\see db_flags"]
    pub fn mdbx_limits_valsize_max(pagesize: isize, flags: MDBX_db_flags_t) -> isize;
}
extern "C" {
    #[doc = " \\brief Returns maximal write transaction size (i.e. limit for summary volume"]
    #[doc = " of dirty pages) in bytes for given page size, or -1 if pagesize is invalid."]
    #[doc = " \\ingroup c_statinfo"]
    pub fn mdbx_limits_txnsize_max(pagesize: isize) -> isize;
}
extern "C" {
    #[doc = " \\brief Set the maximum number of threads/reader slots for the environment."]
    #[doc = " \\ingroup c_settings"]
    #[doc = ""]
    #[doc = " This defines the number of slots in the lock table that is used to track"]
    #[doc = " readers in the the environment. The default is 119 for 4K system page size."]
    #[doc = " Starting a read-only transaction normally ties a lock table slot to the"]
    #[doc = " current thread until the environment closes or the thread exits. If"]
    #[doc = " \\ref MDBX_NOTLS is in use, \\ref mdbx_txn_begin() instead ties the slot to the"]
    #[doc = " \\ref MDBX_txn object until it or the \\ref MDBX_env object is destroyed."]
    #[doc = " This function may only be called after \\ref mdbx_env_create() and before"]
    #[doc = " \\ref mdbx_env_open()."]
    #[doc = " \\see mdbx_env_get_maxreaders()"]
    #[doc = ""]
    #[doc = " \\param [in] env       An environment handle returned"]
    #[doc = "                       by \\ref mdbx_env_create()."]
    #[doc = " \\param [in] readers   The maximum number of reader lock table slots."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_EINVAL   An invalid parameter was specified."]
    #[doc = " \\retval MDBX_EPERM    The environment is already open."]
    pub fn mdbx_env_set_maxreaders(env: *mut MDBX_env, readers: ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get the maximum number of threads/reader slots for the environment."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = " \\see mdbx_env_set_maxreaders()"]
    #[doc = ""]
    #[doc = " \\param [in] env       An environment handle returned"]
    #[doc = "                       by \\ref mdbx_env_create()."]
    #[doc = " \\param [out] readers  Address of an integer to store the number of readers."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_EINVAL   An invalid parameter was specified."]
    pub fn mdbx_env_get_maxreaders(
        env: *const MDBX_env,
        readers: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Set the maximum number of named databases for the environment."]
    #[doc = " \\ingroup c_settings"]
    #[doc = ""]
    #[doc = " This function is only needed if multiple databases will be used in the"]
    #[doc = " environment. Simpler applications that use the environment as a single"]
    #[doc = " unnamed database can ignore this option."]
    #[doc = " This function may only be called after \\ref mdbx_env_create() and before"]
    #[doc = " \\ref mdbx_env_open()."]
    #[doc = ""]
    #[doc = " Currently a moderate number of slots are cheap but a huge number gets"]
    #[doc = " expensive: 7-120 words per transaction, and every \\ref mdbx_dbi_open()"]
    #[doc = " does a linear search of the opened slots."]
    #[doc = " \\see mdbx_env_get_maxdbs()"]
    #[doc = ""]
    #[doc = " \\param [in] env   An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = " \\param [in] dbs   The maximum number of databases."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_EINVAL   An invalid parameter was specified."]
    #[doc = " \\retval MDBX_EPERM    The environment is already open."]
    pub fn mdbx_env_set_maxdbs(env: *mut MDBX_env, dbs: MDBX_dbi) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get the maximum number of named databases for the environment."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = " \\see mdbx_env_set_maxdbs()"]
    #[doc = ""]
    #[doc = " \\param [in] env   An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = " \\param [out] dbs  Address to store the maximum number of databases."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_EINVAL   An invalid parameter was specified."]
    pub fn mdbx_env_get_maxdbs(env: *mut MDBX_env, dbs: *mut MDBX_dbi) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get the maximum size of keys can write."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " \\param [in] env    An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = " \\param [in] flags  Database options (\\ref MDBX_DUPSORT, \\ref MDBX_INTEGERKEY"]
    #[doc = "                    and so on). \\see db_flags"]
    #[doc = ""]
    #[doc = " \\returns The maximum size of a key can write,"]
    #[doc = "          or -1 if something is wrong."]
    pub fn mdbx_env_get_maxkeysize_ex(
        env: *const MDBX_env,
        flags: MDBX_db_flags_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get the maximum size of data we can write."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " \\param [in] env    An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = " \\param [in] flags  Database options (\\ref MDBX_DUPSORT, \\ref MDBX_INTEGERKEY"]
    #[doc = "                    and so on). \\see db_flags"]
    #[doc = ""]
    #[doc = " \\returns The maximum size of a data can write,"]
    #[doc = "          or -1 if something is wrong."]
    pub fn mdbx_env_get_maxvalsize_ex(
        env: *const MDBX_env,
        flags: MDBX_db_flags_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\deprecated Please use \\ref mdbx_env_get_maxkeysize_ex()"]
    #[doc = "              and/or \\ref mdbx_env_get_maxvalsize_ex()"]
    #[doc = " \\ingroup c_statinfo"]
    pub fn mdbx_env_get_maxkeysize(env: *const MDBX_env) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Set application information associated with the \\ref MDBX_env."]
    #[doc = " \\ingroup c_settings"]
    #[doc = " \\see mdbx_env_get_userctx()"]
    #[doc = ""]
    #[doc = " \\param [in] env  An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = " \\param [in] ctx  An arbitrary pointer for whatever the application needs."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_set_userctx(env: *mut MDBX_env, ctx: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get the application information associated with the MDBX_env."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = " \\see mdbx_env_set_userctx()"]
    #[doc = ""]
    #[doc = " \\param [in] env An environment handle returned by \\ref mdbx_env_create()"]
    #[doc = " \\returns The pointer set by \\ref mdbx_env_set_userctx()"]
    #[doc = "          or `NULL` if something wrong."]
    pub fn mdbx_env_get_userctx(env: *const MDBX_env) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " \\brief Create a transaction with a user provided context pointer"]
    #[doc = " for use with the environment."]
    #[doc = " \\ingroup c_transactions"]
    #[doc = ""]
    #[doc = " The transaction handle may be discarded using \\ref mdbx_txn_abort()"]
    #[doc = " or \\ref mdbx_txn_commit()."]
    #[doc = " \\see mdbx_txn_begin()"]
    #[doc = ""]
    #[doc = " \\note A transaction and its cursors must only be used by a single thread,"]
    #[doc = " and a thread may only have a single transaction at a time. If \\ref MDBX_NOTLS"]
    #[doc = " is in use, this does not apply to read-only transactions."]
    #[doc = ""]
    #[doc = " \\note Cursors may not span transactions."]
    #[doc = ""]
    #[doc = " \\param [in] env     An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = ""]
    #[doc = " \\param [in] parent  If this parameter is non-NULL, the new transaction will"]
    #[doc = "                     be a nested transaction, with the transaction indicated"]
    #[doc = "                     by parent as its parent. Transactions may be nested"]
    #[doc = "                     to any level. A parent transaction and its cursors may"]
    #[doc = "                     not issue any other operations than mdbx_txn_commit and"]
    #[doc = "                     \\ref mdbx_txn_abort() while it has active child"]
    #[doc = "                     transactions."]
    #[doc = ""]
    #[doc = " \\param [in] flags   Special options for this transaction. This parameter"]
    #[doc = "                     must be set to 0 or by bitwise OR'ing together one"]
    #[doc = "                     or more of the values described here:"]
    #[doc = "                      - \\ref MDBX_RDONLY   This transaction will not perform"]
    #[doc = "                                           any write operations."]
    #[doc = ""]
    #[doc = "                      - \\ref MDBX_TXN_TRY  Do not block when starting"]
    #[doc = "                                           a write transaction."]
    #[doc = ""]
    #[doc = "                      - \\ref MDBX_SAFE_NOSYNC, \\ref MDBX_NOMETASYNC."]
    #[doc = "                        Do not sync data to disk corresponding"]
    #[doc = "                        to \\ref MDBX_NOMETASYNC or \\ref MDBX_SAFE_NOSYNC"]
    #[doc = "                        description. \\see sync_modes"]
    #[doc = ""]
    #[doc = " \\param [out] txn    Address where the new MDBX_txn handle will be stored."]
    #[doc = ""]
    #[doc = " \\param [in] context A pointer to application context to be associated with"]
    #[doc = "                     created transaction and could be retrieved by"]
    #[doc = "                     \\ref mdbx_txn_get_userctx() until transaction finished."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_PANIC         A fatal error occurred earlier and the"]
    #[doc = "                            environment must be shut down."]
    #[doc = " \\retval MDBX_UNABLE_EXTEND_MAPSIZE  Another process wrote data beyond"]
    #[doc = "                                     this MDBX_env's mapsize and this"]
    #[doc = "                                     environment map must be resized as well."]
    #[doc = "                                     See \\ref mdbx_env_set_mapsize()."]
    #[doc = " \\retval MDBX_READERS_FULL  A read-only transaction was requested and"]
    #[doc = "                            the reader lock table is full."]
    #[doc = "                            See \\ref mdbx_env_set_maxreaders()."]
    #[doc = " \\retval MDBX_ENOMEM        Out of memory."]
    #[doc = " \\retval MDBX_BUSY          The write transaction is already started by the"]
    #[doc = "                            current thread."]
    pub fn mdbx_txn_begin_ex(
        env: *mut MDBX_env,
        parent: *mut MDBX_txn,
        flags: MDBX_txn_flags_t,
        txn: *mut *mut MDBX_txn,
        context: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Set application information associated with the \\ref MDBX_txn."]
    #[doc = " \\ingroup c_transactions"]
    #[doc = " \\see mdbx_txn_get_userctx()"]
    #[doc = ""]
    #[doc = " \\param [in] txn  An transaction handle returned by \\ref mdbx_txn_begin_ex()"]
    #[doc = "                  or \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] ctx  An arbitrary pointer for whatever the application needs."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_txn_set_userctx(txn: *mut MDBX_txn, ctx: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get the application information associated with the MDBX_txn."]
    #[doc = " \\ingroup c_transactions"]
    #[doc = " \\see mdbx_txn_set_userctx()"]
    #[doc = ""]
    #[doc = " \\param [in] txn  An transaction handle returned by \\ref mdbx_txn_begin_ex()"]
    #[doc = "                  or \\ref mdbx_txn_begin()."]
    #[doc = " \\returns The pointer which was passed via the `context` parameter"]
    #[doc = "          of `mdbx_txn_begin_ex()` or set by \\ref mdbx_txn_set_userctx(),"]
    #[doc = "          or `NULL` if something wrong."]
    pub fn mdbx_txn_get_userctx(txn: *const MDBX_txn) -> *mut ::libc::c_void;
}
#[doc = " \\brief Information about the transaction"]
#[doc = " \\ingroup c_statinfo"]
#[doc = " \\see mdbx_txn_info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_txn_info {
    #[doc = " The ID of the transaction. For a READ-ONLY transaction, this corresponds"]
    #[doc = "to the snapshot being read."]
    pub txn_id: u64,
    #[doc = " For READ-ONLY transaction: the lag from a recent MVCC-snapshot, i.e. the"]
    #[doc = "number of committed transaction since read transaction started."]
    #[doc = "For WRITE transaction (provided if `scan_rlt=true`): the lag of the oldest"]
    #[doc = "reader from current transaction (i.e. at least 1 if any reader running)."]
    pub txn_reader_lag: u64,
    #[doc = " Used space by this transaction, i.e. corresponding to the last used"]
    #[doc = " database page."]
    pub txn_space_used: u64,
    #[doc = " Current size of database file."]
    pub txn_space_limit_soft: u64,
    #[doc = " Upper bound for size the database file, i.e. the value `size_upper`"]
    #[doc = "argument of the appropriate call of \\ref mdbx_env_set_geometry()."]
    pub txn_space_limit_hard: u64,
    #[doc = " For READ-ONLY transaction: The total size of the database pages that were"]
    #[doc = "retired by committed write transactions after the reader's MVCC-snapshot,"]
    #[doc = "i.e. the space which would be freed after the Reader releases the"]
    #[doc = "MVCC-snapshot for reuse by completion read transaction."]
    #[doc = "For WRITE transaction: The summarized size of the database pages that were"]
    #[doc = "retired for now due Copy-On-Write during this transaction."]
    pub txn_space_retired: u64,
    #[doc = " For READ-ONLY transaction: the space available for writer(s) and that"]
    #[doc = "must be exhausted for reason to call the Handle-Slow-Readers callback for"]
    #[doc = "this read transaction."]
    #[doc = "For WRITE transaction: the space inside transaction"]
    #[doc = "that left to `MDBX_TXN_FULL` error."]
    pub txn_space_leftover: u64,
    #[doc = " For READ-ONLY transaction (provided if `scan_rlt=true`): The space that"]
    #[doc = "actually become available for reuse when only this transaction will be"]
    #[doc = "finished."]
    #[doc = "For WRITE transaction: The summarized size of the dirty database"]
    #[doc = "pages that generated during this transaction."]
    pub txn_space_dirty: u64,
}
extern "C" {
    #[doc = " \\brief Return information about the MDBX transaction."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " \\param [in] txn        A transaction handle returned by \\ref mdbx_txn_begin()"]
    #[doc = " \\param [out] info      The address of an \\ref MDBX_txn_info structure"]
    #[doc = "                        where the information will be copied."]
    #[doc = " \\param [in] scan_rlt   The boolean flag controls the scan of the read lock"]
    #[doc = "                        table to provide complete information. Such scan"]
    #[doc = "                        is relatively expensive and you can avoid it"]
    #[doc = "                        if corresponding fields are not needed."]
    #[doc = "                        See description of \\ref MDBX_txn_info."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_txn_info(
        txn: *const MDBX_txn,
        info: *mut MDBX_txn_info,
        scan_rlt: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the transaction's MDBX_env."]
    #[doc = " \\ingroup c_transactions"]
    #[doc = ""]
    #[doc = " \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin()"]
    pub fn mdbx_txn_env(txn: *const MDBX_txn) -> *mut MDBX_env;
}
extern "C" {
    #[doc = " \\brief Return the transaction's flags."]
    #[doc = " \\ingroup c_transactions"]
    #[doc = ""]
    #[doc = " This returns the flags associated with this transaction."]
    #[doc = ""]
    #[doc = " \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = ""]
    #[doc = " \\returns A transaction flags, valid if input is an valid transaction,"]
    #[doc = "          otherwise -1."]
    pub fn mdbx_txn_flags(txn: *const MDBX_txn) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Return the transaction's ID."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " This returns the identifier associated with this transaction. For a"]
    #[doc = " read-only transaction, this corresponds to the snapshot being read;"]
    #[doc = " concurrent readers will frequently have the same transaction ID."]
    #[doc = ""]
    #[doc = " \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = ""]
    #[doc = " \\returns A transaction ID, valid if input is an active transaction,"]
    #[doc = "          otherwise 0."]
    pub fn mdbx_txn_id(txn: *const MDBX_txn) -> u64;
}
#[doc = " \\brief Latency of commit stages in 1/65536 of seconds units."]
#[doc = " \\warning This structure may be changed in future releases."]
#[doc = " \\see mdbx_txn_commit_ex()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_commit_latency {
    #[doc = " \\brief Duration of preparation (commit child transactions, update"]
    #[doc = " sub-databases records and cursors destroying)."]
    pub preparation: u32,
    #[doc = " \\brief Duration of GC/freeDB handling & updation."]
    pub gc: u32,
    #[doc = " \\brief Duration of internal audit if enabled."]
    pub audit: u32,
    #[doc = " \\brief Duration of writing dirty/modified data pages."]
    pub write: u32,
    #[doc = " \\brief Duration of syncing written data to the dist/storage."]
    pub sync: u32,
    #[doc = " \\brief Duration of transaction ending (releasing resources)."]
    pub ending: u32,
    #[doc = " \\brief The total duration of a commit."]
    pub whole: u32,
}
extern "C" {
    #[doc = " \\brief Commit all the operations of a transaction into the database and"]
    #[doc = " collect latency information."]
    #[doc = " \\see mdbx_txn_commit()"]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = " \\warning This function may be changed in future releases."]
    pub fn mdbx_txn_commit_ex(
        txn: *mut MDBX_txn,
        latency: *mut MDBX_commit_latency,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Abandon all the operations of the transaction instead of saving them."]
    #[doc = " \\ingroup c_transactions"]
    #[doc = ""]
    #[doc = " The transaction handle is freed. It and its cursors must not be used again"]
    #[doc = " after this call, except with \\ref mdbx_cursor_renew() and"]
    #[doc = " \\ref mdbx_cursor_close()."]
    #[doc = ""]
    #[doc = " If the current thread is not eligible to manage the transaction then"]
    #[doc = " the \\ref MDBX_THREAD_MISMATCH error will returned. Otherwise the transaction"]
    #[doc = " will be aborted and its handle is freed. Thus, a result other than"]
    #[doc = " \\ref MDBX_THREAD_MISMATCH means that the transaction is terminated:"]
    #[doc = "  - Resources are released;"]
    #[doc = "  - Transaction handle is invalid;"]
    #[doc = "  - Cursor(s) associated with transaction must not be used, except with"]
    #[doc = "    \\ref mdbx_cursor_renew() and \\ref mdbx_cursor_close()."]
    #[doc = "    Such cursor(s) must be closed explicitly by \\ref mdbx_cursor_close()"]
    #[doc = "    before or after transaction abort, either can be reused with"]
    #[doc = "    \\ref mdbx_cursor_renew() until it will be explicitly closed by"]
    #[doc = "    \\ref mdbx_cursor_close()."]
    #[doc = ""]
    #[doc = " \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_PANIC            A fatal error occurred earlier and"]
    #[doc = "                               the environment must be shut down."]
    #[doc = " \\retval MDBX_BAD_TXN          Transaction is already finished or never began."]
    #[doc = " \\retval MDBX_EBADSIGN         Transaction object has invalid signature,"]
    #[doc = "                               e.g. transaction was already terminated"]
    #[doc = "                               or memory was corrupted."]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_EINVAL           Transaction handle is NULL."]
    pub fn mdbx_txn_abort(txn: *mut MDBX_txn) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Marks transaction as broken."]
    #[doc = " \\ingroup c_transactions"]
    #[doc = ""]
    #[doc = " Function keeps the transaction handle and corresponding locks, but it"]
    #[doc = " is not possible to perform any operations in a broken transaction."]
    #[doc = " Broken transaction must then be aborted explicitly later."]
    #[doc = ""]
    #[doc = " \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = ""]
    #[doc = " \\see mdbx_txn_abort() \\see mdbx_txn_reset() \\see mdbx_txn_commit()"]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_txn_break(txn: *mut MDBX_txn) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Reset a read-only transaction."]
    #[doc = " \\ingroup c_transactions"]
    #[doc = ""]
    #[doc = " Abort the read-only transaction like \\ref mdbx_txn_abort(), but keep the"]
    #[doc = " transaction handle. Therefore \\ref mdbx_txn_renew() may reuse the handle."]
    #[doc = " This saves allocation overhead if the process will start a new read-only"]
    #[doc = " transaction soon, and also locking overhead if \\ref MDBX_NOTLS is in use. The"]
    #[doc = " reader table lock is released, but the table slot stays tied to its thread"]
    #[doc = " or \\ref MDBX_txn. Use \\ref mdbx_txn_abort() to discard a reset handle, and to"]
    #[doc = " free its lock table slot if \\ref MDBX_NOTLS is in use."]
    #[doc = ""]
    #[doc = " Cursors opened within the transaction must not be used again after this"]
    #[doc = " call, except with \\ref mdbx_cursor_renew() and \\ref mdbx_cursor_close()."]
    #[doc = ""]
    #[doc = " Reader locks generally don't interfere with writers, but they keep old"]
    #[doc = " versions of database pages allocated. Thus they prevent the old pages from"]
    #[doc = " being reused when writers commit new data, and so under heavy load the"]
    #[doc = " database size may grow much more rapidly than otherwise."]
    #[doc = ""]
    #[doc = " \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_PANIC            A fatal error occurred earlier and"]
    #[doc = "                               the environment must be shut down."]
    #[doc = " \\retval MDBX_BAD_TXN          Transaction is already finished or never began."]
    #[doc = " \\retval MDBX_EBADSIGN         Transaction object has invalid signature,"]
    #[doc = "                               e.g. transaction was already terminated"]
    #[doc = "                               or memory was corrupted."]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_EINVAL           Transaction handle is NULL."]
    pub fn mdbx_txn_reset(txn: *mut MDBX_txn) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Renew a read-only transaction."]
    #[doc = " \\ingroup c_transactions"]
    #[doc = ""]
    #[doc = " This acquires a new reader lock for a transaction handle that had been"]
    #[doc = " released by \\ref mdbx_txn_reset(). It must be called before a reset"]
    #[doc = " transaction may be used again."]
    #[doc = ""]
    #[doc = " \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_PANIC            A fatal error occurred earlier and"]
    #[doc = "                               the environment must be shut down."]
    #[doc = " \\retval MDBX_BAD_TXN          Transaction is already finished or never began."]
    #[doc = " \\retval MDBX_EBADSIGN         Transaction object has invalid signature,"]
    #[doc = "                               e.g. transaction was already terminated"]
    #[doc = "                               or memory was corrupted."]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_EINVAL           Transaction handle is NULL."]
    pub fn mdbx_txn_renew(txn: *mut MDBX_txn) -> ::libc::c_int;
}
#[doc = " \\brief The fours integers markers (aka \"canary\") associated with the"]
#[doc = " environment. \\ingroup c_crud \\see mdbx_canary_set() \\see mdbx_canary_get()"]
#[doc = ""]
#[doc = " The `x`, `y` and `z` values could be set by \\ref mdbx_canary_put(), while the"]
#[doc = " 'v' will be always set to the transaction number. Updated values becomes"]
#[doc = " visible outside the current transaction only after it was committed. Current"]
#[doc = " values could be retrieved by \\ref mdbx_canary_get()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDBX_canary {
    pub x: u64,
    pub y: u64,
    pub z: u64,
    pub v: u64,
}
extern "C" {
    #[doc = " \\brief Set integers markers (aka \"canary\") associated with the environment."]
    #[doc = " \\ingroup c_crud"]
    #[doc = " \\see mdbx_canary_get()"]
    #[doc = ""]
    #[doc = " \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin()"]
    #[doc = " \\param [in] canary  A optional pointer to \\ref MDBX_canary structure for `x`,"]
    #[doc = "              `y` and `z` values from."]
    #[doc = "            - If canary is NOT NULL then the `x`, `y` and `z` values will be"]
    #[doc = "              updated from given canary argument, but the 'v' be always set"]
    #[doc = "              to the current transaction number if at least one `x`, `y` or"]
    #[doc = "              `z` values have changed (i.e. if `x`, `y` and `z` have the same"]
    #[doc = "              values as currently present then nothing will be changes or"]
    #[doc = "              updated)."]
    #[doc = "            - if canary is NULL then the `v` value will be explicitly update"]
    #[doc = "              to the current transaction number without changes `x`, `y` nor"]
    #[doc = "              `z`."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_canary_put(txn: *mut MDBX_txn, canary: *const MDBX_canary) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Returns fours integers markers (aka \"canary\") associated with the"]
    #[doc = " environment."]
    #[doc = " \\ingroup c_crud"]
    #[doc = " \\see mdbx_canary_set()"]
    #[doc = ""]
    #[doc = " \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] canary  The address of an MDBX_canary structure where the"]
    #[doc = "                     information will be copied."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_canary_get(txn: *const MDBX_txn, canary: *mut MDBX_canary) -> ::libc::c_int;
}
#[doc = " \\brief A callback function used to compare two keys in a database"]
#[doc = " \\ingroup c_crud"]
#[doc = " \\see mdbx_cmp() \\see mdbx_get_keycmp()"]
#[doc = " \\see mdbx_get_datacmp \\see mdbx_dcmp()"]
pub type MDBX_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(a: *const MDBX_val, b: *const MDBX_val) -> ::libc::c_int,
>;
extern "C" {
    #[doc = " \\brief Open or Create a database in the environment."]
    #[doc = " \\ingroup c_dbi"]
    #[doc = ""]
    #[doc = " A database handle denotes the name and parameters of a database,"]
    #[doc = " independently of whether such a database exists. The database handle may be"]
    #[doc = " discarded by calling \\ref mdbx_dbi_close(). The old database handle is"]
    #[doc = " returned if the database was already open. The handle may only be closed"]
    #[doc = " once."]
    #[doc = ""]
    #[doc = " \\note A notable difference between MDBX and LMDB is that MDBX make handles"]
    #[doc = " opened for existing databases immediately available for other transactions,"]
    #[doc = " regardless this transaction will be aborted or reset. The REASON for this is"]
    #[doc = " to avoiding the requirement for multiple opening a same handles in"]
    #[doc = " concurrent read transactions, and tracking of such open but hidden handles"]
    #[doc = " until the completion of read transactions which opened them."]
    #[doc = ""]
    #[doc = " Nevertheless, the handle for the NEWLY CREATED database will be invisible"]
    #[doc = " for other transactions until the this write transaction is successfully"]
    #[doc = " committed. If the write transaction is aborted the handle will be closed"]
    #[doc = " automatically. After a successful commit the such handle will reside in the"]
    #[doc = " shared environment, and may be used by other transactions."]
    #[doc = ""]
    #[doc = " In contrast to LMDB, the MDBX allow this function to be called from multiple"]
    #[doc = " concurrent transactions or threads in the same process."]
    #[doc = ""]
    #[doc = " To use named database (with name != NULL), \\ref mdbx_env_set_maxdbs()"]
    #[doc = " must be called before opening the environment. Table names are"]
    #[doc = " keys in the internal unnamed database, and may be read but not written."]
    #[doc = ""]
    #[doc = " \\param [in] txn    transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] name   The name of the database to open. If only a single"]
    #[doc = "                    database is needed in the environment,"]
    #[doc = "                    this value may be NULL."]
    #[doc = " \\param [in] flags  Special options for this database. This parameter must"]
    #[doc = "                    be set to 0 or by bitwise OR'ing together one or more"]
    #[doc = "                    of the values described here:"]
    #[doc = "  - \\ref MDBX_REVERSEKEY"]
    #[doc = "      Keys are strings to be compared in reverse order, from the end"]
    #[doc = "      of the strings to the beginning. By default, Keys are treated as"]
    #[doc = "      strings and compared from beginning to end."]
    #[doc = "  - \\ref MDBX_INTEGERKEY"]
    #[doc = "      Keys are binary integers in native byte order, either uint32_t or"]
    #[doc = "      uint64_t, and will be sorted as such. The keys must all be of the"]
    #[doc = "      same size and must be aligned while passing as arguments."]
    #[doc = "  - \\ref MDBX_DUPSORT"]
    #[doc = "      Duplicate keys may be used in the database. Or, from another point of"]
    #[doc = "      view, keys may have multiple data items, stored in sorted order. By"]
    #[doc = "      default keys must be unique and may have only a single data item."]
    #[doc = "  - \\ref MDBX_DUPFIXED"]
    #[doc = "      This flag may only be used in combination with \\ref MDBX_DUPSORT. This"]
    #[doc = "      option tells the library that the data items for this database are"]
    #[doc = "      all the same size, which allows further optimizations in storage and"]
    #[doc = "      retrieval. When all data items are the same size, the"]
    #[doc = "      \\ref MDBX_GET_MULTIPLE, \\ref MDBX_NEXT_MULTIPLE and"]
    #[doc = "      \\ref MDBX_PREV_MULTIPLE cursor operations may be used to retrieve"]
    #[doc = "      multiple items at once."]
    #[doc = "  - \\ref MDBX_INTEGERDUP"]
    #[doc = "      This option specifies that duplicate data items are binary integers,"]
    #[doc = "      similar to \\ref MDBX_INTEGERKEY keys. The data values must all be of the"]
    #[doc = "      same size and must be aligned while passing as arguments."]
    #[doc = "  - \\ref MDBX_REVERSEDUP"]
    #[doc = "      This option specifies that duplicate data items should be compared as"]
    #[doc = "      strings in reverse order (the comparison is performed in the direction"]
    #[doc = "      from the last byte to the first)."]
    #[doc = "  - \\ref MDBX_CREATE"]
    #[doc = "      Create the named database if it doesn't exist. This option is not"]
    #[doc = "      allowed in a read-only transaction or a read-only environment."]
    #[doc = ""]
    #[doc = " \\param [out] dbi     Address where the new \\ref MDBX_dbi handle"]
    #[doc = "                      will be stored."]
    #[doc = ""]
    #[doc = " For \\ref mdbx_dbi_open_ex() additional arguments allow you to set custom"]
    #[doc = " comparison functions for keys and values (for multimaps)."]
    #[doc = " However, I recommend not using custom comparison functions, but instead"]
    #[doc = " converting the keys to one of the forms that are suitable for built-in"]
    #[doc = " comparators (for instance take look to the \\ref value2key)."]
    #[doc = " The reasons to not using custom comparators are:"]
    #[doc = "   - The order of records could not be validated without your code."]
    #[doc = "     So `mdbx_chk` utility will reports \"wrong order\" errors"]
    #[doc = "     and the `-i` option is required to ignore ones."]
    #[doc = "   - A records could not be ordered or sorted without your code."]
    #[doc = "     So mdbx_load utility should be used with `-a` option to preserve"]
    #[doc = "     input data order."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_NOTFOUND   The specified database doesn't exist in the"]
    #[doc = "                         environment and \\ref MDBX_CREATE was not specified."]
    #[doc = " \\retval MDBX_DBS_FULL   Too many databases have been opened."]
    #[doc = "                         \\see mdbx_env_set_maxdbs()"]
    #[doc = " \\retval MDBX_INCOMPATIBLE  Database is incompatible with given flags,"]
    #[doc = "                         i.e. the passed flags is different with which the"]
    #[doc = "                         database was created, or the database was already"]
    #[doc = "                         opened with a different comparison function(s)."]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    pub fn mdbx_dbi_open(
        txn: *mut MDBX_txn,
        name: *const ::libc::c_char,
        flags: MDBX_db_flags_t,
        dbi: *mut MDBX_dbi,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\deprecated Please avoid using custom comparators"]
    #[doc = "              and use mdbx_dbi_open() instead."]
    #[doc = " \\ingroup c_dbi"]
    #[doc = ""]
    #[doc = " \\param [in] txn    transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] name   The name of the database to open. If only a single"]
    #[doc = "                    database is needed in the environment,"]
    #[doc = "                    this value may be NULL."]
    #[doc = " \\param [in] flags  Special options for this database."]
    #[doc = " \\param [in] keycmp  Optional custom key comparison function for a database."]
    #[doc = " \\param [in] datacmp Optional custom data comparison function for a database."]
    #[doc = " \\param [out] dbi    Address where the new MDBX_dbi handle will be stored."]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_dbi_open_ex(
        txn: *mut MDBX_txn,
        name: *const ::libc::c_char,
        flags: MDBX_db_flags_t,
        dbi: *mut MDBX_dbi,
        keycmp: MDBX_cmp_func,
        datacmp: MDBX_cmp_func,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\defgroup value2key Value-to-Key functions to avoid custom comparators"]
    #[doc = " \\see key2value"]
    #[doc = " @{"]
    #[doc = ""]
    #[doc = " The \\ref mdbx_key_from_jsonInteger() build a keys which are comparable with"]
    #[doc = " keys created by \\ref mdbx_key_from_double(). So this allows mixing `int64_t`"]
    #[doc = " and IEEE754 double values in one index for JSON-numbers with restriction for"]
    #[doc = " integer numbers range corresponding to RFC-7159, i.e. \\f$[-2^{53}+1,"]
    #[doc = " 2^{53}-1]\\f$. See bottom of page 6 at https://tools.ietf.org/html/rfc7159"]
    pub fn mdbx_key_from_jsonInteger(json_integer: i64) -> u64;
}
extern "C" {
    pub fn mdbx_key_from_double(ieee754_64bit: f64) -> u64;
}
extern "C" {
    pub fn mdbx_key_from_ptrdouble(ieee754_64bit: *const f64) -> u64;
}
extern "C" {
    pub fn mdbx_key_from_float(ieee754_32bit: f32) -> u32;
}
extern "C" {
    pub fn mdbx_key_from_ptrfloat(ieee754_32bit: *const f32) -> u32;
}
extern "C" {
    #[doc = " \\defgroup key2value Key-to-Value functions to avoid custom comparators"]
    #[doc = " \\see value2key"]
    #[doc = " @{"]
    pub fn mdbx_jsonInteger_from_key(arg1: MDBX_val) -> i64;
}
extern "C" {
    pub fn mdbx_double_from_key(arg1: MDBX_val) -> f64;
}
extern "C" {
    pub fn mdbx_float_from_key(arg1: MDBX_val) -> f32;
}
extern "C" {
    pub fn mdbx_int32_from_key(arg1: MDBX_val) -> i32;
}
extern "C" {
    pub fn mdbx_int64_from_key(arg1: MDBX_val) -> i64;
}
extern "C" {
    #[doc = " \\brief Retrieve statistics for a database."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi     A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [out] stat   The address of an \\ref MDBX_stat structure where"]
    #[doc = "                     the statistics will be copied."]
    #[doc = " \\param [in] bytes   The size of \\ref MDBX_stat."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_EINVAL   An invalid parameter was specified."]
    pub fn mdbx_dbi_stat(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        stat: *mut MDBX_stat,
        bytes: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Retrieve depth (bitmask) information of nested dupsort (multi-value)"]
    #[doc = " B+trees for given database."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi     A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [out] mask   The address of an uint32_t value where the bitmask"]
    #[doc = "                     will be stored."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_EINVAL       An invalid parameter was specified."]
    #[doc = " \\retval MDBX_RESULT_TRUE  The dbi isn't a dupsort (multi-value) database."]
    pub fn mdbx_dbi_dupsort_depthmask(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        mask: *mut u32,
    ) -> ::libc::c_int;
}
#[doc = " DB was written in this txn"]
pub const MDBX_DBI_DIRTY: MDBX_dbi_state_t = 1;
#[doc = " Named-DB record is older than txnID"]
pub const MDBX_DBI_STALE: MDBX_dbi_state_t = 2;
#[doc = " Named-DB handle opened in this txn"]
pub const MDBX_DBI_FRESH: MDBX_dbi_state_t = 4;
#[doc = " Named-DB handle created in this txn"]
pub const MDBX_DBI_CREAT: MDBX_dbi_state_t = 8;
#[doc = " \\brief DBI state bits returted by \\ref mdbx_dbi_flags_ex()"]
#[doc = " \\ingroup c_statinfo"]
#[doc = " \\see mdbx_dbi_flags_ex()"]
pub type MDBX_dbi_state_t = u32;
extern "C" {
    #[doc = " \\brief Retrieve the DB flags and status for a database handle."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " \\param [in] txn     A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi     A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [out] flags  Address where the flags will be returned."]
    #[doc = " \\param [out] state  Address where the state will be returned."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_dbi_flags_ex(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        flags: *mut ::libc::c_uint,
        state: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Close a database handle. Normally unnecessary."]
    #[doc = " \\ingroup c_dbi"]
    #[doc = ""]
    #[doc = " Closing a database handle is not necessary, but lets \\ref mdbx_dbi_open()"]
    #[doc = " reuse the handle value. Usually it's better to set a bigger"]
    #[doc = " \\ref mdbx_env_set_maxdbs(), unless that value would be large."]
    #[doc = ""]
    #[doc = " \\note Use with care."]
    #[doc = " This call is synchronized via mutex with \\ref mdbx_dbi_close(), but NOT with"]
    #[doc = " other transactions running by other threads. The \"next\" version of libmdbx"]
    #[doc = " (\\ref MithrilDB) will solve this issue."]
    #[doc = ""]
    #[doc = " Handles should only be closed if no other threads are going to reference"]
    #[doc = " the database handle or one of its cursors any further. Do not close a handle"]
    #[doc = " if an existing transaction has modified its database. Doing so can cause"]
    #[doc = " misbehavior from database corruption to errors like \\ref MDBX_BAD_DBI"]
    #[doc = " (since the DB name is gone)."]
    #[doc = ""]
    #[doc = " \\param [in] env  An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = " \\param [in] dbi  A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_dbi_close(env: *mut MDBX_env, dbi: MDBX_dbi) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Empty or delete and close a database."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " \\see mdbx_dbi_close() \\see mdbx_dbi_open()"]
    #[doc = ""]
    #[doc = " \\param [in] txn  A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi  A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [in] del  `false` to empty the DB, `true` to delete it"]
    #[doc = "                  from the environment and close the DB handle."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_drop(txn: *mut MDBX_txn, dbi: MDBX_dbi, del: bool) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get items from a database."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " This function retrieves key/data pairs from the database. The address"]
    #[doc = " and length of the data associated with the specified key are returned"]
    #[doc = " in the structure to which data refers."]
    #[doc = " If the database supports duplicate keys (\\ref MDBX_DUPSORT) then the"]
    #[doc = " first data item for the key will be returned. Retrieval of other"]
    #[doc = " items requires the use of \\ref mdbx_cursor_get()."]
    #[doc = ""]
    #[doc = " \\note The memory pointed to by the returned values is owned by the"]
    #[doc = " database. The caller need not dispose of the memory, and may not"]
    #[doc = " modify it in any way. For values returned in a read-only transaction"]
    #[doc = " any modification attempts will cause a `SIGSEGV`."]
    #[doc = ""]
    #[doc = " \\note Values returned from the database are valid only until a"]
    #[doc = " subsequent update operation, or the end of the transaction."]
    #[doc = ""]
    #[doc = " \\param [in] txn       A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi       A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [in] key       The key to search for in the database."]
    #[doc = " \\param [in,out] data  The data corresponding to the key."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_NOTFOUND  The key was not in the database."]
    #[doc = " \\retval MDBX_EINVAL    An invalid parameter was specified."]
    pub fn mdbx_get(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        key: *const MDBX_val,
        data: *mut MDBX_val,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get items from a database"]
    #[doc = " and optionally number of data items for a given key."]
    #[doc = ""]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " Briefly this function does the same as \\ref mdbx_get() with a few"]
    #[doc = " differences:"]
    #[doc = "  1. If values_count is NOT NULL, then returns the count"]
    #[doc = "     of multi-values/duplicates for a given key."]
    #[doc = "  2. Updates BOTH the key and the data for pointing to the actual key-value"]
    #[doc = "     pair inside the database."]
    #[doc = ""]
    #[doc = " \\param [in] txn           A transaction handle returned"]
    #[doc = "                           by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi           A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [in,out] key       The key to search for in the database."]
    #[doc = " \\param [in,out] data      The data corresponding to the key."]
    #[doc = " \\param [out] values_count The optional address to return number of values"]
    #[doc = "                           associated with given key:"]
    #[doc = "                            = 0 - in case \\ref MDBX_NOTFOUND error;"]
    #[doc = "                            = 1 - exactly for databases"]
    #[doc = "                                  WITHOUT \\ref MDBX_DUPSORT;"]
    #[doc = "                            >= 1 for databases WITH \\ref MDBX_DUPSORT."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_NOTFOUND  The key was not in the database."]
    #[doc = " \\retval MDBX_EINVAL    An invalid parameter was specified."]
    pub fn mdbx_get_ex(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        key: *mut MDBX_val,
        data: *mut MDBX_val,
        values_count: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get equal or great item from a database."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " Briefly this function does the same as \\ref mdbx_get() with a few"]
    #[doc = " differences:"]
    #[doc = " 1. Return equal or great (due comparison function) key-value"]
    #[doc = "    pair, but not only exactly matching with the key."]
    #[doc = " 2. On success return \\ref MDBX_SUCCESS if key found exactly,"]
    #[doc = "    and \\ref MDBX_RESULT_TRUE otherwise. Moreover, for databases with"]
    #[doc = "    \\ref MDBX_DUPSORT flag the data argument also will be used to match over"]
    #[doc = "    multi-value/duplicates, and \\ref MDBX_SUCCESS will be returned only when"]
    #[doc = "    BOTH the key and the data match exactly."]
    #[doc = " 3. Updates BOTH the key and the data for pointing to the actual key-value"]
    #[doc = "    pair inside the database."]
    #[doc = ""]
    #[doc = " \\param [in] txn           A transaction handle returned"]
    #[doc = "                           by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi           A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [in,out] key       The key to search for in the database."]
    #[doc = " \\param [in,out] data      The data corresponding to the key."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and \\ref MDBX_RESULT_FALSE"]
    #[doc = "          or \\ref MDBX_RESULT_TRUE on success (as described above)."]
    #[doc = "          Some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_NOTFOUND      The key was not in the database."]
    #[doc = " \\retval MDBX_EINVAL        An invalid parameter was specified."]
    pub fn mdbx_get_equal_or_great(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        key: *mut MDBX_val,
        data: *mut MDBX_val,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Store items into a database."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " This function stores key/data pairs in the database. The default behavior"]
    #[doc = " is to enter the new key/data pair, replacing any previously existing key"]
    #[doc = " if duplicates are disallowed, or adding a duplicate data item if"]
    #[doc = " duplicates are allowed (see \\ref MDBX_DUPSORT)."]
    #[doc = ""]
    #[doc = " \\param [in] txn        A transaction handle returned"]
    #[doc = "                        by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi        A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [in] key        The key to store in the database."]
    #[doc = " \\param [in,out] data   The data to store."]
    #[doc = " \\param [in] flags      Special options for this operation."]
    #[doc = "                        This parameter must be set to 0 or by bitwise OR'ing"]
    #[doc = "                        together one or more of the values described here:"]
    #[doc = "   - \\ref MDBX_NODUPDATA"]
    #[doc = "      Enter the new key-value pair only if it does not already appear"]
    #[doc = "      in the database. This flag may only be specified if the database"]
    #[doc = "      was opened with \\ref MDBX_DUPSORT. The function will return"]
    #[doc = "      \\ref MDBX_KEYEXIST if the key/data pair already appears in the database."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_NOOVERWRITE"]
    #[doc = "      Enter the new key/data pair only if the key does not already appear"]
    #[doc = "      in the database. The function will return \\ref MDBX_KEYEXIST if the key"]
    #[doc = "      already appears in the database, even if the database supports"]
    #[doc = "      duplicates (see \\ref  MDBX_DUPSORT). The data parameter will be set"]
    #[doc = "      to point to the existing item."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_CURRENT"]
    #[doc = "      Update an single existing entry, but not add new ones. The function will"]
    #[doc = "      return \\ref MDBX_NOTFOUND if the given key not exist in the database."]
    #[doc = "      In case multi-values for the given key, with combination of"]
    #[doc = "      the \\ref MDBX_ALLDUPS will replace all multi-values,"]
    #[doc = "      otherwise return the \\ref MDBX_EMULTIVAL."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_RESERVE"]
    #[doc = "      Reserve space for data of the given size, but don't copy the given"]
    #[doc = "      data. Instead, return a pointer to the reserved space, which the"]
    #[doc = "      caller can fill in later - before the next update operation or the"]
    #[doc = "      transaction ends. This saves an extra memcpy if the data is being"]
    #[doc = "      generated later. MDBX does nothing else with this memory, the caller"]
    #[doc = "      is expected to modify all of the space requested. This flag must not"]
    #[doc = "      be specified if the database was opened with \\ref MDBX_DUPSORT."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_APPEND"]
    #[doc = "      Append the given key/data pair to the end of the database. This option"]
    #[doc = "      allows fast bulk loading when keys are already known to be in the"]
    #[doc = "      correct order. Loading unsorted keys with this flag will cause"]
    #[doc = "      a \\ref MDBX_EKEYMISMATCH error."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_APPENDDUP"]
    #[doc = "      As above, but for sorted dup data."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_MULTIPLE"]
    #[doc = "      Store multiple contiguous data elements in a single request. This flag"]
    #[doc = "      may only be specified if the database was opened with"]
    #[doc = "      \\ref MDBX_DUPFIXED. With combination the \\ref MDBX_ALLDUPS"]
    #[doc = "      will replace all multi-values."]
    #[doc = "      The data argument must be an array of two \\ref MDBX_val. The `iov_len`"]
    #[doc = "      of the first \\ref MDBX_val must be the size of a single data element."]
    #[doc = "      The `iov_base` of the first \\ref MDBX_val must point to the beginning"]
    #[doc = "      of the array of contiguous data elements which must be properly aligned"]
    #[doc = "      in case of database with \\ref MDBX_INTEGERDUP flag."]
    #[doc = "      The `iov_len` of the second \\ref MDBX_val must be the count of the"]
    #[doc = "      number of data elements to store. On return this field will be set to"]
    #[doc = "      the count of the number of elements actually written. The `iov_base` of"]
    #[doc = "      the second \\ref MDBX_val is unused."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_KEYEXIST  The key/value pair already exists in the database."]
    #[doc = " \\retval MDBX_MAP_FULL  The database is full, see \\ref mdbx_env_set_mapsize()."]
    #[doc = " \\retval MDBX_TXN_FULL  The transaction has too many dirty pages."]
    #[doc = " \\retval MDBX_EACCES    An attempt was made to write"]
    #[doc = "                        in a read-only transaction."]
    #[doc = " \\retval MDBX_EINVAL    An invalid parameter was specified."]
    pub fn mdbx_put(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        key: *const MDBX_val,
        data: *mut MDBX_val,
        flags: MDBX_put_flags_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Replace items in a database."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " This function allows to update or delete an existing value at the same time"]
    #[doc = " as the previous value is retrieved. If the argument new_data equal is NULL"]
    #[doc = " zero, the removal is performed, otherwise the update/insert."]
    #[doc = ""]
    #[doc = " The current value may be in an already changed (aka dirty) page. In this"]
    #[doc = " case, the page will be overwritten during the update, and the old value will"]
    #[doc = " be lost. Therefore, an additional buffer must be passed via old_data"]
    #[doc = " argument initially to copy the old value. If the buffer passed in is too"]
    #[doc = " small, the function will return \\ref MDBX_RESULT_TRUE by setting iov_len"]
    #[doc = " field pointed by old_data argument to the appropriate value, without"]
    #[doc = " performing any changes."]
    #[doc = ""]
    #[doc = " For databases with non-unique keys (i.e. with \\ref MDBX_DUPSORT flag),"]
    #[doc = " another use case is also possible, when by old_data argument selects a"]
    #[doc = " specific item from multi-value/duplicates with the same key for deletion or"]
    #[doc = " update. To select this scenario in flags should simultaneously specify"]
    #[doc = " \\ref MDBX_CURRENT and \\ref MDBX_NOOVERWRITE. This combination is chosen"]
    #[doc = " because it makes no sense, and thus allows you to identify the request of"]
    #[doc = " such a scenario."]
    #[doc = ""]
    #[doc = " \\param [in] txn           A transaction handle returned"]
    #[doc = "                           by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi           A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [in] key           The key to store in the database."]
    #[doc = " \\param [in] new_data      The data to store, if NULL then deletion will"]
    #[doc = "                           be performed."]
    #[doc = " \\param [in,out] old_data  The buffer for retrieve previous value as describe"]
    #[doc = "                           above."]
    #[doc = " \\param [in] flags         Special options for this operation."]
    #[doc = "                           This parameter must be set to 0 or by bitwise"]
    #[doc = "                           OR'ing together one or more of the values"]
    #[doc = "                           described in \\ref mdbx_put() description above,"]
    #[doc = "                           and additionally"]
    #[doc = "                           (\\ref MDBX_CURRENT | \\ref MDBX_NOOVERWRITE)"]
    #[doc = "                           combination for selection particular item from"]
    #[doc = "                           multi-value/duplicates."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_replace(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        key: *const MDBX_val,
        new_data: *mut MDBX_val,
        old_data: *mut MDBX_val,
        flags: MDBX_put_flags_t,
    ) -> ::libc::c_int;
}
pub type MDBX_preserve_func = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::libc::c_void,
        target: *mut MDBX_val,
        src: *const ::libc::c_void,
        bytes: usize,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn mdbx_replace_ex(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        key: *const MDBX_val,
        new_data: *mut MDBX_val,
        old_data: *mut MDBX_val,
        flags: MDBX_put_flags_t,
        preserver: MDBX_preserve_func,
        preserver_context: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Delete items from a database."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " This function removes key/data pairs from the database."]
    #[doc = ""]
    #[doc = " \\note The data parameter is NOT ignored regardless the database does"]
    #[doc = " support sorted duplicate data items or not. If the data parameter"]
    #[doc = " is non-NULL only the matching data item will be deleted. Otherwise, if data"]
    #[doc = " parameter is NULL, any/all value(s) for specified key will be deleted."]
    #[doc = ""]
    #[doc = " This function will return \\ref MDBX_NOTFOUND if the specified key/data"]
    #[doc = " pair is not in the database."]
    #[doc = ""]
    #[doc = " \\param [in] txn   A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi   A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [in] key   The key to delete from the database."]
    #[doc = " \\param [in] data  The data to delete."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_EACCES   An attempt was made to write"]
    #[doc = "                       in a read-only transaction."]
    #[doc = " \\retval MDBX_EINVAL   An invalid parameter was specified."]
    pub fn mdbx_del(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        key: *const MDBX_val,
        data: *const MDBX_val,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Create a cursor handle but not bind it to transaction nor DBI handle."]
    #[doc = " \\ingroup c_cursors"]
    #[doc = ""]
    #[doc = " An capable of operation cursor is associated with a specific transaction and"]
    #[doc = " database. A cursor cannot be used when its database handle is closed. Nor"]
    #[doc = " when its transaction has ended, except with \\ref mdbx_cursor_bind() and"]
    #[doc = " \\ref mdbx_cursor_renew()."]
    #[doc = " Also it can be discarded with \\ref mdbx_cursor_close()."]
    #[doc = ""]
    #[doc = " A cursor must be closed explicitly always, before or after its transaction"]
    #[doc = " ends. It can be reused with \\ref mdbx_cursor_bind()"]
    #[doc = " or \\ref mdbx_cursor_renew() before finally closing it."]
    #[doc = ""]
    #[doc = " \\note In contrast to LMDB, the MDBX required that any opened cursors can be"]
    #[doc = " reused and must be freed explicitly, regardless ones was opened in a"]
    #[doc = " read-only or write transaction. The REASON for this is eliminates ambiguity"]
    #[doc = " which helps to avoid errors such as: use-after-free, double-free, i.e."]
    #[doc = " memory corruption and segfaults."]
    #[doc = ""]
    #[doc = " \\param [in] context A pointer to application context to be associated with"]
    #[doc = "                     created cursor and could be retrieved by"]
    #[doc = "                     \\ref mdbx_cursor_get_userctx() until cursor closed."]
    #[doc = ""]
    #[doc = " \\returns Created cursor handle or NULL in case out of memory."]
    pub fn mdbx_cursor_create(context: *mut ::libc::c_void) -> *mut MDBX_cursor;
}
extern "C" {
    #[doc = " \\brief Set application information associated with the \\ref MDBX_cursor."]
    #[doc = " \\ingroup c_crud"]
    #[doc = " \\see mdbx_cursor_get_userctx()"]
    #[doc = ""]
    #[doc = " \\param [in] cursor  An cursor handle returned by \\ref mdbx_cursor_create()"]
    #[doc = "                     or \\ref mdbx_cursor_open()."]
    #[doc = " \\param [in] ctx     An arbitrary pointer for whatever the application needs."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_cursor_set_userctx(
        cursor: *mut MDBX_cursor,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get the application information associated with the MDBX_cursor."]
    #[doc = " \\ingroup c_crud"]
    #[doc = " \\see mdbx_cursor_set_userctx()"]
    #[doc = ""]
    #[doc = " \\param [in] cursor  An cursor handle returned by \\ref mdbx_cursor_create()"]
    #[doc = "                     or \\ref mdbx_cursor_open()."]
    #[doc = " \\returns The pointer which was passed via the `context` parameter"]
    #[doc = "          of `mdbx_cursor_create()` or set by \\ref mdbx_cursor_set_userctx(),"]
    #[doc = "          or `NULL` if something wrong."]
    pub fn mdbx_cursor_get_userctx(cursor: *const MDBX_cursor) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " \\brief Bind cursor to specified transaction and DBI handle."]
    #[doc = " \\ingroup c_cursors"]
    #[doc = ""]
    #[doc = " Using of the `mdbx_cursor_bind()` is equivalent to calling"]
    #[doc = " \\ref mdbx_cursor_renew() but with specifying an arbitrary dbi handle."]
    #[doc = ""]
    #[doc = " An capable of operation cursor is associated with a specific transaction and"]
    #[doc = " database. The cursor may be associated with a new transaction,"]
    #[doc = " and referencing a new or the same database handle as it was created with."]
    #[doc = " This may be done whether the previous transaction is live or dead."]
    #[doc = ""]
    #[doc = " \\note In contrast to LMDB, the MDBX required that any opened cursors can be"]
    #[doc = " reused and must be freed explicitly, regardless ones was opened in a"]
    #[doc = " read-only or write transaction. The REASON for this is eliminates ambiguity"]
    #[doc = " which helps to avoid errors such as: use-after-free, double-free, i.e."]
    #[doc = " memory corruption and segfaults."]
    #[doc = ""]
    #[doc = " \\param [in] txn      A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi      A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [out] cursor  A cursor handle returned by \\ref mdbx_cursor_create()."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_cursor_bind(
        txn: *mut MDBX_txn,
        cursor: *mut MDBX_cursor,
        dbi: MDBX_dbi,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Create a cursor handle for the specified transaction and DBI handle."]
    #[doc = " \\ingroup c_cursors"]
    #[doc = ""]
    #[doc = " Using of the `mdbx_cursor_open()` is equivalent to calling"]
    #[doc = " \\ref mdbx_cursor_create() and then \\ref mdbx_cursor_bind() functions."]
    #[doc = ""]
    #[doc = " An capable of operation cursor is associated with a specific transaction and"]
    #[doc = " database. A cursor cannot be used when its database handle is closed. Nor"]
    #[doc = " when its transaction has ended, except with \\ref mdbx_cursor_bind() and"]
    #[doc = " \\ref mdbx_cursor_renew()."]
    #[doc = " Also it can be discarded with \\ref mdbx_cursor_close()."]
    #[doc = ""]
    #[doc = " A cursor must be closed explicitly always, before or after its transaction"]
    #[doc = " ends. It can be reused with \\ref mdbx_cursor_bind()"]
    #[doc = " or \\ref mdbx_cursor_renew() before finally closing it."]
    #[doc = ""]
    #[doc = " \\note In contrast to LMDB, the MDBX required that any opened cursors can be"]
    #[doc = " reused and must be freed explicitly, regardless ones was opened in a"]
    #[doc = " read-only or write transaction. The REASON for this is eliminates ambiguity"]
    #[doc = " which helps to avoid errors such as: use-after-free, double-free, i.e."]
    #[doc = " memory corruption and segfaults."]
    #[doc = ""]
    #[doc = " \\param [in] txn      A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi      A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [out] cursor  Address where the new \\ref MDBX_cursor handle will be"]
    #[doc = "                      stored."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_cursor_open(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        cursor: *mut *mut MDBX_cursor,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Close a cursor handle."]
    #[doc = " \\ingroup c_cursors"]
    #[doc = ""]
    #[doc = " The cursor handle will be freed and must not be used again after this call,"]
    #[doc = " but its transaction may still be live."]
    #[doc = ""]
    #[doc = " \\note In contrast to LMDB, the MDBX required that any opened cursors can be"]
    #[doc = " reused and must be freed explicitly, regardless ones was opened in a"]
    #[doc = " read-only or write transaction. The REASON for this is eliminates ambiguity"]
    #[doc = " which helps to avoid errors such as: use-after-free, double-free, i.e."]
    #[doc = " memory corruption and segfaults."]
    #[doc = ""]
    #[doc = " \\param [in] cursor  A cursor handle returned by \\ref mdbx_cursor_open()"]
    #[doc = "                     or \\ref mdbx_cursor_create()."]
    pub fn mdbx_cursor_close(cursor: *mut MDBX_cursor);
}
extern "C" {
    #[doc = " \\brief Renew a cursor handle."]
    #[doc = " \\ingroup c_cursors"]
    #[doc = ""]
    #[doc = " An capable of operation cursor is associated with a specific transaction and"]
    #[doc = " database. The cursor may be associated with a new transaction,"]
    #[doc = " and referencing a new or the same database handle as it was created with."]
    #[doc = " This may be done whether the previous transaction is live or dead."]
    #[doc = ""]
    #[doc = " Using of the `mdbx_cursor_renew()` is equivalent to calling"]
    #[doc = " \\ref mdbx_cursor_bind() with the DBI handle that previously"]
    #[doc = " the cursor was used with."]
    #[doc = ""]
    #[doc = " \\note In contrast to LMDB, the MDBX allow any cursor to be re-used by using"]
    #[doc = " \\ref mdbx_cursor_renew(), to avoid unnecessary malloc/free overhead until it"]
    #[doc = " freed by \\ref mdbx_cursor_close()."]
    #[doc = ""]
    #[doc = " \\param [in] txn      A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] cursor   A cursor handle returned by \\ref mdbx_cursor_open()."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_EINVAL  An invalid parameter was specified."]
    pub fn mdbx_cursor_renew(txn: *mut MDBX_txn, cursor: *mut MDBX_cursor) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Return the cursor's transaction handle."]
    #[doc = " \\ingroup c_cursors"]
    #[doc = ""]
    #[doc = " \\param [in] cursor A cursor handle returned by \\ref mdbx_cursor_open()."]
    pub fn mdbx_cursor_txn(cursor: *const MDBX_cursor) -> *mut MDBX_txn;
}
extern "C" {
    #[doc = " \\brief Return the cursor's database handle."]
    #[doc = " \\ingroup c_cursors"]
    #[doc = ""]
    #[doc = " \\param [in] cursor  A cursor handle returned by \\ref mdbx_cursor_open()."]
    pub fn mdbx_cursor_dbi(cursor: *const MDBX_cursor) -> MDBX_dbi;
}
extern "C" {
    #[doc = " \\brief Copy cursor position and state."]
    #[doc = " \\ingroup c_cursors"]
    #[doc = ""]
    #[doc = " \\param [in] src       A source cursor handle returned"]
    #[doc = " by \\ref mdbx_cursor_create() or \\ref mdbx_cursor_open()."]
    #[doc = ""]
    #[doc = " \\param [in,out] dest  A destination cursor handle returned"]
    #[doc = " by \\ref mdbx_cursor_create() or \\ref mdbx_cursor_open()."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_cursor_copy(src: *const MDBX_cursor, dest: *mut MDBX_cursor) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Retrieve by cursor."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " This function retrieves key/data pairs from the database. The address and"]
    #[doc = " length of the key are returned in the object to which key refers (except"]
    #[doc = " for the case of the \\ref MDBX_SET option, in which the key object is"]
    #[doc = " unchanged), and the address and length of the data are returned in the object"]
    #[doc = " to which data refers."]
    #[doc = " \\see mdbx_get()"]
    #[doc = ""]
    #[doc = " \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open()."]
    #[doc = " \\param [in,out] key   The key for a retrieved item."]
    #[doc = " \\param [in,out] data  The data of a retrieved item."]
    #[doc = " \\param [in] op        A cursor operation \\ref MDBX_cursor_op."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_NOTFOUND  No matching key found."]
    #[doc = " \\retval MDBX_EINVAL    An invalid parameter was specified."]
    pub fn mdbx_cursor_get(
        cursor: *mut MDBX_cursor,
        key: *mut MDBX_val,
        data: *mut MDBX_val,
        op: MDBX_cursor_op,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Store by cursor."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " This function stores key/data pairs into the database. The cursor is"]
    #[doc = " positioned at the new item, or on failure usually near it."]
    #[doc = ""]
    #[doc = " \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open()."]
    #[doc = " \\param [in] key       The key operated on."]
    #[doc = " \\param [in,out] data  The data operated on."]
    #[doc = " \\param [in] flags     Options for this operation. This parameter"]
    #[doc = "                       must be set to 0 or by bitwise OR'ing together"]
    #[doc = "                       one or more of the values described here:"]
    #[doc = "  - \\ref MDBX_CURRENT"]
    #[doc = "      Replace the item at the current cursor position. The key parameter"]
    #[doc = "      must still be provided, and must match it, otherwise the function"]
    #[doc = "      return \\ref MDBX_EKEYMISMATCH. With combination the"]
    #[doc = "      \\ref MDBX_ALLDUPS will replace all multi-values."]
    #[doc = ""]
    #[doc = "      \\note MDBX allows (unlike LMDB) you to change the size of the data and"]
    #[doc = "      automatically handles reordering for sorted duplicates"]
    #[doc = "      (see \\ref MDBX_DUPSORT)."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_NODUPDATA"]
    #[doc = "      Enter the new key-value pair only if it does not already appear in the"]
    #[doc = "      database. This flag may only be specified if the database was opened"]
    #[doc = "      with \\ref MDBX_DUPSORT. The function will return \\ref MDBX_KEYEXIST"]
    #[doc = "      if the key/data pair already appears in the database."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_NOOVERWRITE"]
    #[doc = "      Enter the new key/data pair only if the key does not already appear"]
    #[doc = "      in the database. The function will return \\ref MDBX_KEYEXIST if the key"]
    #[doc = "      already appears in the database, even if the database supports"]
    #[doc = "      duplicates (\\ref MDBX_DUPSORT)."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_RESERVE"]
    #[doc = "      Reserve space for data of the given size, but don't copy the given"]
    #[doc = "      data. Instead, return a pointer to the reserved space, which the"]
    #[doc = "      caller can fill in later - before the next update operation or the"]
    #[doc = "      transaction ends. This saves an extra memcpy if the data is being"]
    #[doc = "      generated later. This flag must not be specified if the database"]
    #[doc = "      was opened with \\ref MDBX_DUPSORT."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_APPEND"]
    #[doc = "      Append the given key/data pair to the end of the database. No key"]
    #[doc = "      comparisons are performed. This option allows fast bulk loading when"]
    #[doc = "      keys are already known to be in the correct order. Loading unsorted"]
    #[doc = "      keys with this flag will cause a \\ref MDBX_KEYEXIST error."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_APPENDDUP"]
    #[doc = "      As above, but for sorted dup data."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_MULTIPLE"]
    #[doc = "      Store multiple contiguous data elements in a single request. This flag"]
    #[doc = "      may only be specified if the database was opened with"]
    #[doc = "      \\ref MDBX_DUPFIXED. With combination the \\ref MDBX_ALLDUPS"]
    #[doc = "      will replace all multi-values."]
    #[doc = "      The data argument must be an array of two \\ref MDBX_val. The `iov_len`"]
    #[doc = "      of the first \\ref MDBX_val must be the size of a single data element."]
    #[doc = "      The `iov_base` of the first \\ref MDBX_val must point to the beginning"]
    #[doc = "      of the array of contiguous data elements which must be properly aligned"]
    #[doc = "      in case of database with \\ref MDBX_INTEGERDUP flag."]
    #[doc = "      The `iov_len` of the second \\ref MDBX_val must be the count of the"]
    #[doc = "      number of data elements to store. On return this field will be set to"]
    #[doc = "      the count of the number of elements actually written. The `iov_base` of"]
    #[doc = "      the second \\ref MDBX_val is unused."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_EKEYMISMATCH  The given key value is mismatched to the current"]
    #[doc = "                            cursor position"]
    #[doc = " \\retval MDBX_MAP_FULL      The database is full,"]
    #[doc = "                             see \\ref mdbx_env_set_mapsize()."]
    #[doc = " \\retval MDBX_TXN_FULL      The transaction has too many dirty pages."]
    #[doc = " \\retval MDBX_EACCES        An attempt was made to write in a read-only"]
    #[doc = "                            transaction."]
    #[doc = " \\retval MDBX_EINVAL        An invalid parameter was specified."]
    pub fn mdbx_cursor_put(
        cursor: *mut MDBX_cursor,
        key: *const MDBX_val,
        data: *mut MDBX_val,
        flags: MDBX_put_flags_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Delete current key/data pair."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " This function deletes the key/data pair to which the cursor refers. This"]
    #[doc = " does not invalidate the cursor, so operations such as \\ref MDBX_NEXT can"]
    #[doc = " still be used on it. Both \\ref MDBX_NEXT and \\ref MDBX_GET_CURRENT will"]
    #[doc = " return the same record after this operation."]
    #[doc = ""]
    #[doc = " \\param [in] cursor  A cursor handle returned by mdbx_cursor_open()."]
    #[doc = " \\param [in] flags   Options for this operation. This parameter must be set"]
    #[doc = " to one of the values described here."]
    #[doc = ""]
    #[doc = "  - \\ref MDBX_CURRENT Delete only single entry at current cursor position."]
    #[doc = "  - \\ref MDBX_ALLDUPS"]
    #[doc = "    or \\ref MDBX_NODUPDATA (supported for compatibility)"]
    #[doc = "      Delete all of the data items for the current key. This flag has effect"]
    #[doc = "      only for database(s) was created with \\ref MDBX_DUPSORT."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_MAP_FULL      The database is full,"]
    #[doc = "                            see \\ref mdbx_env_set_mapsize()."]
    #[doc = " \\retval MDBX_TXN_FULL      The transaction has too many dirty pages."]
    #[doc = " \\retval MDBX_EACCES        An attempt was made to write in a read-only"]
    #[doc = "                            transaction."]
    #[doc = " \\retval MDBX_EINVAL        An invalid parameter was specified."]
    pub fn mdbx_cursor_del(cursor: *mut MDBX_cursor, flags: MDBX_put_flags_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Return count of duplicates for current key."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " This call is valid for all databases, but reasonable only for that support"]
    #[doc = " sorted duplicate data items \\ref MDBX_DUPSORT."]
    #[doc = ""]
    #[doc = " \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open()."]
    #[doc = " \\param [out] pcount   Address where the count will be stored."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_THREAD_MISMATCH  Given transaction is not owned"]
    #[doc = "                               by current thread."]
    #[doc = " \\retval MDBX_EINVAL   Cursor is not initialized, or an invalid parameter"]
    #[doc = "                       was specified."]
    pub fn mdbx_cursor_count(cursor: *const MDBX_cursor, pcount: *mut usize) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Determines whether the cursor is pointed to a key-value pair or not,"]
    #[doc = " i.e. was not positioned or points to the end of data."]
    #[doc = " \\ingroup c_cursors"]
    #[doc = ""]
    #[doc = " \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open()."]
    #[doc = ""]
    #[doc = " \\returns A \\ref MDBX_RESULT_TRUE or \\ref MDBX_RESULT_FALSE value,"]
    #[doc = "          otherwise the error code:"]
    #[doc = " \\retval MDBX_RESULT_TRUE    No more data available or cursor not"]
    #[doc = "                             positioned"]
    #[doc = " \\retval MDBX_RESULT_FALSE   A data is available"]
    #[doc = " \\retval Otherwise the error code"]
    pub fn mdbx_cursor_eof(cursor: *const MDBX_cursor) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Determines whether the cursor is pointed to the first key-value pair"]
    #[doc = " or not. \\ingroup c_cursors"]
    #[doc = ""]
    #[doc = " \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open()."]
    #[doc = ""]
    #[doc = " \\returns A MDBX_RESULT_TRUE or MDBX_RESULT_FALSE value,"]
    #[doc = "          otherwise the error code:"]
    #[doc = " \\retval MDBX_RESULT_TRUE   Cursor positioned to the first key-value pair"]
    #[doc = " \\retval MDBX_RESULT_FALSE  Cursor NOT positioned to the first key-value"]
    #[doc = " pair \\retval Otherwise the error code"]
    pub fn mdbx_cursor_on_first(cursor: *const MDBX_cursor) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Determines whether the cursor is pointed to the last key-value pair"]
    #[doc = " or not. \\ingroup c_cursors"]
    #[doc = ""]
    #[doc = " \\param [in] cursor    A cursor handle returned by \\ref mdbx_cursor_open()."]
    #[doc = ""]
    #[doc = " \\returns A \\ref MDBX_RESULT_TRUE or \\ref MDBX_RESULT_FALSE value,"]
    #[doc = "          otherwise the error code:"]
    #[doc = " \\retval MDBX_RESULT_TRUE   Cursor positioned to the last key-value pair"]
    #[doc = " \\retval MDBX_RESULT_FALSE  Cursor NOT positioned to the last key-value pair"]
    #[doc = " \\retval Otherwise the error code"]
    pub fn mdbx_cursor_on_last(cursor: *const MDBX_cursor) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Estimates the distance between cursors as a number of elements."]
    #[doc = " \\ingroup c_rqest"]
    #[doc = ""]
    #[doc = " This function performs a rough estimate based only on b-tree pages that are"]
    #[doc = " common for the both cursor's stacks. The results of such estimation can be"]
    #[doc = " used to build and/or optimize query execution plans."]
    #[doc = ""]
    #[doc = " Please see notes on accuracy of the result in the details"]
    #[doc = " of \\ref c_rqest section."]
    #[doc = ""]
    #[doc = " Both cursors must be initialized for the same database and the same"]
    #[doc = " transaction."]
    #[doc = ""]
    #[doc = " \\param [in] first            The first cursor for estimation."]
    #[doc = " \\param [in] last             The second cursor for estimation."]
    #[doc = " \\param [out] distance_items  The pointer to store estimated distance value,"]
    #[doc = "                              i.e. `*distance_items = distance(first, last)`."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_estimate_distance(
        first: *const MDBX_cursor,
        last: *const MDBX_cursor,
        distance_items: *mut isize,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Estimates the move distance."]
    #[doc = " \\ingroup c_rqest"]
    #[doc = ""]
    #[doc = " This function performs a rough estimate distance between the current"]
    #[doc = " cursor position and next position after the specified move-operation with"]
    #[doc = " given key and data. The results of such estimation can be used to build"]
    #[doc = " and/or optimize query execution plans. Current cursor position and state are"]
    #[doc = " preserved."]
    #[doc = ""]
    #[doc = " Please see notes on accuracy of the result in the details"]
    #[doc = " of \\ref c_rqest section."]
    #[doc = ""]
    #[doc = " \\param [in] cursor            Cursor for estimation."]
    #[doc = " \\param [in,out] key           The key for a retrieved item."]
    #[doc = " \\param [in,out] data          The data of a retrieved item."]
    #[doc = " \\param [in] move_op           A cursor operation \\ref MDBX_cursor_op."]
    #[doc = " \\param [out] distance_items   A pointer to store estimated move distance"]
    #[doc = "                               as the number of elements."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_estimate_move(
        cursor: *const MDBX_cursor,
        key: *mut MDBX_val,
        data: *mut MDBX_val,
        move_op: MDBX_cursor_op,
        distance_items: *mut isize,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Estimates the size of a range as a number of elements."]
    #[doc = " \\ingroup c_rqest"]
    #[doc = ""]
    #[doc = " The results of such estimation can be used to build and/or optimize query"]
    #[doc = " execution plans."]
    #[doc = ""]
    #[doc = " Please see notes on accuracy of the result in the details"]
    #[doc = " of \\ref c_rqest section."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param [in] txn        A transaction handle returned"]
    #[doc = "                        by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi        A database handle returned by  \\ref mdbx_dbi_open()."]
    #[doc = " \\param [in] begin_key  The key of range beginning or NULL for explicit FIRST."]
    #[doc = " \\param [in] begin_data Optional additional data to seeking among sorted"]
    #[doc = "                        duplicates."]
    #[doc = "                        Only for \\ref MDBX_DUPSORT, NULL otherwise."]
    #[doc = " \\param [in] end_key    The key of range ending or NULL for explicit LAST."]
    #[doc = " \\param [in] end_data   Optional additional data to seeking among sorted"]
    #[doc = "                        duplicates."]
    #[doc = "                        Only for \\ref MDBX_DUPSORT, NULL otherwise."]
    #[doc = " \\param [out] distance_items  A pointer to store range estimation result."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_estimate_range(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        begin_key: *mut MDBX_val,
        begin_data: *mut MDBX_val,
        end_key: *mut MDBX_val,
        end_data: *mut MDBX_val,
        distance_items: *mut isize,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Determines whether the given address is on a dirty database page of"]
    #[doc = " the transaction or not. \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " Ultimately, this allows to avoid copy data from non-dirty pages."]
    #[doc = ""]
    #[doc = " \"Dirty\" pages are those that have already been changed during a write"]
    #[doc = " transaction. Accordingly, any further changes may result in such pages being"]
    #[doc = " overwritten. Therefore, all functions libmdbx performing changes inside the"]
    #[doc = " database as arguments should NOT get pointers to data in those pages. In"]
    #[doc = " turn, \"not dirty\" pages before modification will be copied."]
    #[doc = ""]
    #[doc = " In other words, data from dirty pages must either be copied before being"]
    #[doc = " passed as arguments for further processing or rejected at the argument"]
    #[doc = " validation stage. Thus, `mdbx_is_dirty()` allows you to get rid of"]
    #[doc = " unnecessary copying, and perform a more complete check of the arguments."]
    #[doc = ""]
    #[doc = " \\note The address passed must point to the beginning of the data. This is"]
    #[doc = " the only way to ensure that the actual page header is physically located in"]
    #[doc = " the same memory page, including for multi-pages with long data."]
    #[doc = ""]
    #[doc = " \\note In rare cases the function may return a false positive answer"]
    #[doc = " (\\ref MDBX_RESULT_TRUE when data is NOT on a dirty page), but never a false"]
    #[doc = " negative if the arguments are correct."]
    #[doc = ""]
    #[doc = " \\param [in] txn      A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] ptr      The address of data to check."]
    #[doc = ""]
    #[doc = " \\returns A MDBX_RESULT_TRUE or MDBX_RESULT_FALSE value,"]
    #[doc = "          otherwise the error code:"]
    #[doc = " \\retval MDBX_RESULT_TRUE    Given address is on the dirty page."]
    #[doc = " \\retval MDBX_RESULT_FALSE   Given address is NOT on the dirty page."]
    #[doc = " \\retval Otherwise the error code."]
    pub fn mdbx_is_dirty(txn: *const MDBX_txn, ptr: *const ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Sequence generation for a database."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " The function allows to create a linear sequence of unique positive integers"]
    #[doc = " for each database. The function can be called for a read transaction to"]
    #[doc = " retrieve the current sequence value, and the increment must be zero."]
    #[doc = " Sequence changes become visible outside the current write transaction after"]
    #[doc = " it is committed, and discarded on abort."]
    #[doc = ""]
    #[doc = " \\param [in] txn        A transaction handle returned"]
    #[doc = "                        by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi        A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [out] result    The optional address where the value of sequence"]
    #[doc = "                        before the change will be stored."]
    #[doc = " \\param [in] increment  Value to increase the sequence,"]
    #[doc = "                        must be 0 for read-only transactions."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = "          some possible errors are:"]
    #[doc = " \\retval MDBX_RESULT_TRUE   Increasing the sequence has resulted in an"]
    #[doc = "                            overflow and therefore cannot be executed."]
    pub fn mdbx_dbi_sequence(
        txn: *mut MDBX_txn,
        dbi: MDBX_dbi,
        result: *mut u64,
        increment: u64,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Compare two keys according to a particular database."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " This returns a comparison as if the two data items were keys in the"]
    #[doc = " specified database."]
    #[doc = ""]
    #[doc = " \\warning There ss a Undefined behavior if one of arguments is invalid."]
    #[doc = ""]
    #[doc = " \\param [in] txn   A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi   A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [in] a     The first item to compare."]
    #[doc = " \\param [in] b     The second item to compare."]
    #[doc = ""]
    #[doc = " \\returns < 0 if a < b, 0 if a == b, > 0 if a > b"]
    pub fn mdbx_cmp(
        txn: *const MDBX_txn,
        dbi: MDBX_dbi,
        a: *const MDBX_val,
        b: *const MDBX_val,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Returns default internal key's comparator for given database flags."]
    #[doc = " \\ingroup c_extra"]
    pub fn mdbx_get_keycmp(flags: MDBX_db_flags_t) -> MDBX_cmp_func;
}
extern "C" {
    #[doc = " \\brief Compare two data items according to a particular database."]
    #[doc = " \\ingroup c_crud"]
    #[doc = ""]
    #[doc = " This returns a comparison as if the two items were data items of the"]
    #[doc = " specified database."]
    #[doc = ""]
    #[doc = " \\warning There ss a Undefined behavior if one of arguments is invalid."]
    #[doc = ""]
    #[doc = " \\param [in] txn   A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [in] dbi   A database handle returned by \\ref mdbx_dbi_open()."]
    #[doc = " \\param [in] a     The first item to compare."]
    #[doc = " \\param [in] b     The second item to compare."]
    #[doc = ""]
    #[doc = " \\returns < 0 if a < b, 0 if a == b, > 0 if a > b"]
    pub fn mdbx_dcmp(
        txn: *const MDBX_txn,
        dbi: MDBX_dbi,
        a: *const MDBX_val,
        b: *const MDBX_val,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Returns default internal data's comparator for given database flags"]
    #[doc = " \\ingroup c_extra"]
    pub fn mdbx_get_datacmp(flags: MDBX_db_flags_t) -> MDBX_cmp_func;
}
#[doc = " \\brief A callback function used to enumerate the reader lock table."]
#[doc = " \\ingroup c_statinfo"]
#[doc = ""]
#[doc = " \\param [in] ctx           An arbitrary context pointer for the callback."]
#[doc = " \\param [in] num           The serial number during enumeration,"]
#[doc = "                           starting from 1."]
#[doc = " \\param [in] slot          The reader lock table slot number."]
#[doc = " \\param [in] txnid         The ID of the transaction being read,"]
#[doc = "                           i.e. the MVCC-snapshot number."]
#[doc = " \\param [in] lag           The lag from a recent MVCC-snapshot,"]
#[doc = "                           i.e. the number of committed write transactions"]
#[doc = "                           since the current read transaction started."]
#[doc = " \\param [in] pid           The reader process ID."]
#[doc = " \\param [in] thread        The reader thread ID."]
#[doc = " \\param [in] bytes_used    The number of last used page in the MVCC-snapshot"]
#[doc = "                           which being read,"]
#[doc = "                           i.e. database file can't shrinked beyond this."]
#[doc = " \\param [in] bytes_retired The total size of the database pages that were"]
#[doc = "                           retired by committed write transactions after"]
#[doc = "                           the reader's MVCC-snapshot,"]
#[doc = "                           i.e. the space which would be freed after"]
#[doc = "                           the Reader releases the MVCC-snapshot"]
#[doc = "                           for reuse by completion read transaction."]
#[doc = ""]
#[doc = " \\returns < 0 on failure, >= 0 on success. \\see mdbx_reader_list()"]
pub type MDBX_reader_list_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        num: ::libc::c_int,
        slot: ::libc::c_int,
        pid: mdbx_pid_t,
        thread: mdbx_tid_t,
        txnid: u64,
        lag: u64,
        bytes_used: usize,
        bytes_retained: usize,
    ) -> ::libc::c_int,
>;
extern "C" {
    #[doc = " \\brief Enumerate the entries in the reader lock table."]
    #[doc = ""]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " \\param [in] env     An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = " \\param [in] func    A \\ref MDBX_reader_list_func function."]
    #[doc = " \\param [in] ctx     An arbitrary context pointer for the enumeration"]
    #[doc = "                     function."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = " or \\ref MDBX_RESULT_TRUE if the reader lock table is empty."]
    pub fn mdbx_reader_list(
        env: *const MDBX_env,
        func: MDBX_reader_list_func,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Check for stale entries in the reader lock table."]
    #[doc = " \\ingroup c_extra"]
    #[doc = ""]
    #[doc = " \\param [in] env     An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = " \\param [out] dead   Number of stale slots that were cleared."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = " or \\ref MDBX_RESULT_TRUE if a dead reader(s) found or mutex was recovered."]
    pub fn mdbx_reader_check(env: *mut MDBX_env, dead: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Returns a lag of the reading for the given transaction."]
    #[doc = " \\ingroup c_statinfo"]
    #[doc = ""]
    #[doc = " Returns an information for estimate how much given read-only"]
    #[doc = " transaction is lagging relative the to actual head."]
    #[doc = " \\deprecated Please use \\ref mdbx_txn_info() instead."]
    #[doc = ""]
    #[doc = " \\param [in] txn       A transaction handle returned by \\ref mdbx_txn_begin()."]
    #[doc = " \\param [out] percent  Percentage of page allocation in the database."]
    #[doc = ""]
    #[doc = " \\returns Number of transactions committed after the given was started for"]
    #[doc = "          read, or negative value on failure."]
    pub fn mdbx_txn_straggler(txn: *const MDBX_txn, percent: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Registers the current thread as a reader for the environment."]
    #[doc = " \\ingroup c_extra"]
    #[doc = ""]
    #[doc = " To perform read operations without blocking, a reader slot must be assigned"]
    #[doc = " for each thread. However, this assignment requires a short-term lock"]
    #[doc = " acquisition which is performed automatically. This function allows you to"]
    #[doc = " assign the reader slot in advance and thus avoid capturing the blocker when"]
    #[doc = " the read transaction starts firstly from current thread."]
    #[doc = " \\see mdbx_thread_unregister()"]
    #[doc = ""]
    #[doc = " \\note Threads are registered automatically the first time a read transaction"]
    #[doc = "       starts. Therefore, there is no need to use this function, except in"]
    #[doc = "       special cases."]
    #[doc = ""]
    #[doc = " \\param [in] env   An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success,"]
    #[doc = " or \\ref MDBX_RESULT_TRUE if thread is already registered."]
    pub fn mdbx_thread_register(env: *const MDBX_env) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Unregisters the current thread as a reader for the environment."]
    #[doc = " \\ingroup c_extra"]
    #[doc = ""]
    #[doc = " To perform read operations without blocking, a reader slot must be assigned"]
    #[doc = " for each thread. However, the assigned reader slot will remain occupied until"]
    #[doc = " the thread ends or the environment closes. This function allows you to"]
    #[doc = " explicitly release the assigned reader slot."]
    #[doc = " \\see mdbx_thread_register()"]
    #[doc = ""]
    #[doc = " \\param [in] env   An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success, or"]
    #[doc = " \\ref MDBX_RESULT_TRUE if thread is not registered or already unregistered."]
    pub fn mdbx_thread_unregister(env: *const MDBX_env) -> ::libc::c_int;
}
#[doc = " \\brief A Handle-Slow-Readers callback function to resolve database"]
#[doc = " full/overflow issue due to a reader(s) which prevents the old data from being"]
#[doc = " recycled."]
#[doc = " \\ingroup c_err"]
#[doc = ""]
#[doc = " Read transactions prevent reuse of pages freed by newer write transactions,"]
#[doc = " thus the database can grow quickly. This callback will be called when there"]
#[doc = " is not enough space in the database (i.e. before increasing the database size"]
#[doc = " or before \\ref MDBX_MAP_FULL error) and thus can be used to resolve issues"]
#[doc = " with a \"long-lived\" read transactions."]
#[doc = " \\see long-lived-read"]
#[doc = ""]
#[doc = " Using this callback you can choose how to resolve the situation:"]
#[doc = "   - abort the write transaction with an error;"]
#[doc = "   - wait for the read transaction(s) to complete;"]
#[doc = "   - notify a thread performing a long-lived read transaction"]
#[doc = "     and wait for an effect;"]
#[doc = "   - kill the thread or whole process that performs the long-lived read"]
#[doc = "     transaction;"]
#[doc = ""]
#[doc = " Depending on the arguments and needs, your implementation may wait,"]
#[doc = " terminate a process or thread that is performing a long read, or perform"]
#[doc = " some other action. In doing so it is important that the returned code always"]
#[doc = " corresponds to the performed action."]
#[doc = ""]
#[doc = " \\param [in] env     An environment handle returned by \\ref mdbx_env_create()."]
#[doc = " \\param [in] txn     The current write transaction which internally at"]
#[doc = "                     the \\ref MDBX_MAP_FULL condition."]
#[doc = " \\param [in] pid     A pid of the reader process."]
#[doc = " \\param [in] tid     A thread_id of the reader thread."]
#[doc = " \\param [in] laggard An oldest read transaction number on which stalled."]
#[doc = " \\param [in] gap     A lag from the last committed txn."]
#[doc = " \\param [in] space   A space that actually become available for reuse after"]
#[doc = "                     this reader finished. The callback function can take"]
#[doc = "                     this value into account to evaluate the impact that"]
#[doc = "                     a long-running transaction has."]
#[doc = " \\param [in] retry   A retry number starting from 0."]
#[doc = "                     If callback has returned 0 at least once, then at end"]
#[doc = "                     of current handling loop the callback function will be"]
#[doc = "                     called additionally with negative value to notify about"]
#[doc = "                     the end of loop. The callback function can use this value"]
#[doc = "                     to implement timeout logic while waiting for readers."]
#[doc = ""]
#[doc = " \\returns The RETURN CODE determines the further actions libmdbx and must"]
#[doc = "          match the action which was executed by the callback:"]
#[doc = ""]
#[doc = " \\retval -2 or less  An error condition and the reader was not killed."]
#[doc = ""]
#[doc = " \\retval -1          The callback was unable to solve the problem and"]
#[doc = "                     agreed on \\ref MDBX_MAP_FULL error;"]
#[doc = "                     libmdbx should increase the database size or"]
#[doc = "                     return \\ref MDBX_MAP_FULL error."]
#[doc = ""]
#[doc = " \\retval 0 (zero)    The callback solved the problem or just waited for"]
#[doc = "                     a while, libmdbx should rescan the reader lock table and"]
#[doc = "                     retry. This also includes a situation when corresponding"]
#[doc = "                     transaction terminated in normal way by"]
#[doc = "                     \\ref mdbx_txn_abort() or \\ref mdbx_txn_reset(),"]
#[doc = "                     and my be restarted. I.e. reader slot don't needed"]
#[doc = "                     to be cleaned from transaction."]
#[doc = ""]
#[doc = " \\retval 1           Transaction aborted asynchronous and reader slot"]
#[doc = "                     should be cleared immediately, i.e. read transaction"]
#[doc = "                     will not continue but \\ref mdbx_txn_abort()"]
#[doc = "                     or \\ref mdbx_txn_reset() will be called later."]
#[doc = ""]
#[doc = " \\retval 2 or great  The reader process was terminated or killed,"]
#[doc = "                     and libmdbx should entirely reset reader registration."]
#[doc = ""]
#[doc = " \\see mdbx_env_set_hsr() \\see mdbx_env_get_hsr()"]
pub type MDBX_hsr_func = ::std::option::Option<
    unsafe extern "C" fn(
        env: *const MDBX_env,
        txn: *const MDBX_txn,
        pid: mdbx_pid_t,
        tid: mdbx_tid_t,
        laggard: u64,
        gap: ::libc::c_uint,
        space: usize,
        retry: ::libc::c_int,
    ) -> ::libc::c_int,
>;
extern "C" {
    #[doc = " \\brief Sets a Handle-Slow-Readers callback to resolve database full/overflow"]
    #[doc = " issue due to a reader(s) which prevents the old data from being recycled."]
    #[doc = " \\ingroup c_err"]
    #[doc = ""]
    #[doc = " The callback will only be triggered when the database is full due to a"]
    #[doc = " reader(s) prevents the old data from being recycled."]
    #[doc = ""]
    #[doc = " \\see mdbx_env_get_hsr()"]
    #[doc = " \\see long-lived-read"]
    #[doc = ""]
    #[doc = " \\param [in] env             An environment handle returned"]
    #[doc = "                             by \\ref mdbx_env_create()."]
    #[doc = " \\param [in] hsr_callback    A \\ref MDBX_hsr_func function"]
    #[doc = "                             or NULL to disable."]
    #[doc = ""]
    #[doc = " \\returns A non-zero error value on failure and 0 on success."]
    pub fn mdbx_env_set_hsr(env: *mut MDBX_env, hsr_callback: MDBX_hsr_func) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Gets current Handle-Slow-Readers callback used to resolve database"]
    #[doc = " full/overflow issue due to a reader(s) which prevents the old data from being"]
    #[doc = " recycled."]
    #[doc = " \\see mdbx_env_set_hsr()"]
    #[doc = ""]
    #[doc = " \\param [in] env   An environment handle returned by \\ref mdbx_env_create()."]
    #[doc = ""]
    #[doc = " \\returns A MDBX_hsr_func function or NULL if disabled"]
    #[doc = "          or something wrong."]
    pub fn mdbx_env_get_hsr(env: *const MDBX_env) -> MDBX_hsr_func;
}
#[repr(u32)]
#[doc = " \\brief Page types for traverse the b-tree."]
#[doc = " \\see mdbx_env_pgwalk() \\see MDBX_pgvisitor_func"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MDBX_page_type_t {
    MDBX_page_broken = 0,
    MDBX_page_meta = 1,
    MDBX_page_large = 2,
    MDBX_page_branch = 3,
    MDBX_page_leaf = 4,
    MDBX_page_dupfixed_leaf = 5,
    MDBX_subpage_leaf = 6,
    MDBX_subpage_dupfixed_leaf = 7,
    MDBX_subpage_broken = 8,
}
#[doc = " \\brief Callback function for traverse the b-tree. \\see mdbx_env_pgwalk()"]
pub type MDBX_pgvisitor_func = ::std::option::Option<
    unsafe extern "C" fn(
        pgno: u64,
        number: ::libc::c_uint,
        ctx: *mut ::libc::c_void,
        deep: ::libc::c_int,
        dbi: *const ::libc::c_char,
        page_size: usize,
        type_: MDBX_page_type_t,
        err: MDBX_error_t,
        nentries: usize,
        payload_bytes: usize,
        header_bytes: usize,
        unused_bytes: usize,
    ) -> ::libc::c_int,
>;
extern "C" {
    #[doc = " \\brief B-tree traversal function."]
    pub fn mdbx_env_pgwalk(
        txn: *mut MDBX_txn,
        visitor: MDBX_pgvisitor_func,
        ctx: *mut ::libc::c_void,
        dont_check_keys_ordering: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Open an environment instance using specific meta-page"]
    #[doc = " for checking and recovery."]
    #[doc = ""]
    #[doc = " This function mostly of internal API for `mdbx_chk` utility and subject to"]
    #[doc = " change at any time. Do not use this function to avoid shooting your own"]
    #[doc = " leg(s)."]
    pub fn mdbx_env_open_for_recovery(
        env: *mut MDBX_env,
        pathname: *const ::libc::c_char,
        target_meta: ::libc::c_uint,
        writeable: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " \\brief Turn database to the specified meta-page."]
    #[doc = ""]
    #[doc = " This function mostly of internal API for `mdbx_chk` utility and subject to"]
    #[doc = " change at any time. Do not use this function to avoid shooting your own"]
    #[doc = " leg(s)."]
    pub fn mdbx_env_turn_for_recovery(
        env: *mut MDBX_env,
        target_meta: ::libc::c_uint,
    ) -> ::libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
